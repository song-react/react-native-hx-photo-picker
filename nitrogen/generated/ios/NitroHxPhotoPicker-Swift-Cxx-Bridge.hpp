///
/// NitroHxPhotoPicker-Swift-Cxx-Bridge.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `ActivityIndicatorStyleOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class ActivityIndicatorStyleOption; }
// Forward declaration of `AlbumListConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct AlbumListConfig; }
// Forward declaration of `AlbumShowModeConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct AlbumShowModeConfig; }
// Forward declaration of `AlbumShowModeOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class AlbumShowModeOption; }
// Forward declaration of `AlbumTitleViewConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct AlbumTitleViewConfig; }
// Forward declaration of `AppearanceStyleOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class AppearanceStyleOption; }
// Forward declaration of `ArrowViewConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct ArrowViewConfig; }
// Forward declaration of `BarStyleOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class BarStyleOption; }
// Forward declaration of `BlurEffectStyleOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class BlurEffectStyleOption; }
// Forward declaration of `CameraAspectRatioConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct CameraAspectRatioConfig; }
// Forward declaration of `CameraAspectRatioOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class CameraAspectRatioOption; }
// Forward declaration of `CameraConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct CameraConfig; }
// Forward declaration of `CameraDevicePositionOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class CameraDevicePositionOption; }
// Forward declaration of `CameraFlashModeOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class CameraFlashModeOption; }
// Forward declaration of `CameraPresetOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class CameraPresetOption; }
// Forward declaration of `CameraTakePhotoModeOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class CameraTakePhotoModeOption; }
// Forward declaration of `CameraVideoCodecTypeOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class CameraVideoCodecTypeOption; }
// Forward declaration of `EditorBrushConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorBrushConfig; }
// Forward declaration of `EditorButtonTypeOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class EditorButtonTypeOption; }
// Forward declaration of `EditorChartletConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorChartletConfig; }
// Forward declaration of `EditorChartletItemConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorChartletItemConfig; }
// Forward declaration of `EditorChartletLoadSceneOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class EditorChartletLoadSceneOption; }
// Forward declaration of `EditorConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorConfig; }
// Forward declaration of `EditorCropSizeConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorCropSizeConfig; }
// Forward declaration of `EditorFilterConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorFilterConfig; }
// Forward declaration of `EditorJumpPresentStyleOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class EditorJumpPresentStyleOption; }
// Forward declaration of `EditorJumpPushStyleOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class EditorJumpPushStyleOption; }
// Forward declaration of `EditorJumpStyleConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorJumpStyleConfig; }
// Forward declaration of `EditorJumpStyleOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class EditorJumpStyleOption; }
// Forward declaration of `EditorMaskTypeConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorMaskTypeConfig; }
// Forward declaration of `EditorMaskTypeOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class EditorMaskTypeOption; }
// Forward declaration of `EditorMosaicConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorMosaicConfig; }
// Forward declaration of `EditorMusicConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorMusicConfig; }
// Forward declaration of `EditorPhotoConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorPhotoConfig; }
// Forward declaration of `EditorRatioConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorRatioConfig; }
// Forward declaration of `EditorTextConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorTextConfig; }
// Forward declaration of `EditorToolOptionConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorToolOptionConfig; }
// Forward declaration of `EditorToolOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class EditorToolOption; }
// Forward declaration of `EditorToolsViewConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorToolsViewConfig; }
// Forward declaration of `EditorURLConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorURLConfig; }
// Forward declaration of `EditorURLPathTypeOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class EditorURLPathTypeOption; }
// Forward declaration of `EditorVideoConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorVideoConfig; }
// Forward declaration of `EditorVideoCropTimeConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EditorVideoCropTimeConfig; }
// Forward declaration of `EmptyViewConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EmptyViewConfig; }
// Forward declaration of `ExportPresetOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class ExportPresetOption; }
// Forward declaration of `FontConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct FontConfig; }
// Forward declaration of `FontFamilyOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class FontFamilyOption; }
// Forward declaration of `FontWeightOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class FontWeightOption; }
// Forward declaration of `HybridHXPhotoPickerSpec` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { class HybridHXPhotoPickerSpec; }
// Forward declaration of `IndicatorTypeOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class IndicatorTypeOption; }
// Forward declaration of `InterfaceOrientationOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class InterfaceOrientationOption; }
// Forward declaration of `LanguageTypeOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class LanguageTypeOption; }
// Forward declaration of `LoadNetworkVideoModeOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class LoadNetworkVideoModeOption; }
// Forward declaration of `ModalPresentationStyleOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class ModalPresentationStyleOption; }
// Forward declaration of `NotAuthorizedConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct NotAuthorizedConfig; }
// Forward declaration of `PhotoAlbumControllerConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PhotoAlbumControllerConfig; }
// Forward declaration of `PhotoListAssetNumberConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PhotoListAssetNumberConfig; }
// Forward declaration of `PhotoListCameraCellConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PhotoListCameraCellConfig; }
// Forward declaration of `PhotoListCameraTypeConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PhotoListCameraTypeConfig; }
// Forward declaration of `PhotoListCameraTypeOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class PhotoListCameraTypeOption; }
// Forward declaration of `PhotoListCellConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PhotoListCellConfig; }
// Forward declaration of `PhotoListConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PhotoListConfig; }
// Forward declaration of `PhotoListLimitCellConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PhotoListLimitCellConfig; }
// Forward declaration of `PhotoListSaveSystemAlbumTypeConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PhotoListSaveSystemAlbumTypeConfig; }
// Forward declaration of `PhotoListSaveSystemAlbumTypeOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class PhotoListSaveSystemAlbumTypeOption; }
// Forward declaration of `PhotoPickerPreviewJumpStyleOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class PhotoPickerPreviewJumpStyleOption; }
// Forward declaration of `PickerAssetOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class PickerAssetOption; }
// Forward declaration of `PickerBottomViewConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PickerBottomViewConfig; }
// Forward declaration of `PickerPhotoAsset` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PickerPhotoAsset; }
// Forward declaration of `PickerPresentStyleConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PickerPresentStyleConfig; }
// Forward declaration of `PickerPresentStyleOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class PickerPresentStyleOption; }
// Forward declaration of `PickerResult` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PickerResult; }
// Forward declaration of `PickerSelectModeOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class PickerSelectModeOption; }
// Forward declaration of `PickerViewCancelPositionOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class PickerViewCancelPositionOption; }
// Forward declaration of `PickerViewCancelTypeOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class PickerViewCancelTypeOption; }
// Forward declaration of `PreviewPlayTypeOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class PreviewPlayTypeOption; }
// Forward declaration of `PreviewViewConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PreviewViewConfig; }
// Forward declaration of `PreviewViewHDRMarkConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PreviewViewHDRMarkConfig; }
// Forward declaration of `PreviewViewLivePhotoMarkConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PreviewViewLivePhotoMarkConfig; }
// Forward declaration of `SelectBoxConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct SelectBoxConfig; }
// Forward declaration of `SelectBoxStyleOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class SelectBoxStyleOption; }
// Forward declaration of `SelectionTapActionOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class SelectionTapActionOption; }
// Forward declaration of `Size` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct Size; }
// Forward declaration of `SortOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class SortOption; }
// Forward declaration of `StatusBarStyleOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class StatusBarStyleOption; }
// Forward declaration of `SystemCameraConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct SystemCameraConfig; }
// Forward declaration of `SystemCameraDeviceOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class SystemCameraDeviceOption; }
// Forward declaration of `SystemCameraMediaTypeOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class SystemCameraMediaTypeOption; }
// Forward declaration of `SystemCameraVideoQualityOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class SystemCameraVideoQualityOption; }

// Forward declarations of Swift defined types
// Forward declaration of `HybridHXPhotoPickerSpec_cxx` to properly resolve imports.
namespace NitroHxPhotoPicker { class HybridHXPhotoPickerSpec_cxx; }

// Include C++ defined types
#include "ActivityIndicatorStyleOption.hpp"
#include "AlbumListConfig.hpp"
#include "AlbumShowModeConfig.hpp"
#include "AlbumShowModeOption.hpp"
#include "AlbumTitleViewConfig.hpp"
#include "AppearanceStyleOption.hpp"
#include "ArrowViewConfig.hpp"
#include "BarStyleOption.hpp"
#include "BlurEffectStyleOption.hpp"
#include "CameraAspectRatioConfig.hpp"
#include "CameraAspectRatioOption.hpp"
#include "CameraConfig.hpp"
#include "CameraDevicePositionOption.hpp"
#include "CameraFlashModeOption.hpp"
#include "CameraPresetOption.hpp"
#include "CameraTakePhotoModeOption.hpp"
#include "CameraVideoCodecTypeOption.hpp"
#include "EditorBrushConfig.hpp"
#include "EditorButtonTypeOption.hpp"
#include "EditorChartletConfig.hpp"
#include "EditorChartletItemConfig.hpp"
#include "EditorChartletLoadSceneOption.hpp"
#include "EditorConfig.hpp"
#include "EditorCropSizeConfig.hpp"
#include "EditorFilterConfig.hpp"
#include "EditorJumpPresentStyleOption.hpp"
#include "EditorJumpPushStyleOption.hpp"
#include "EditorJumpStyleConfig.hpp"
#include "EditorJumpStyleOption.hpp"
#include "EditorMaskTypeConfig.hpp"
#include "EditorMaskTypeOption.hpp"
#include "EditorMosaicConfig.hpp"
#include "EditorMusicConfig.hpp"
#include "EditorPhotoConfig.hpp"
#include "EditorRatioConfig.hpp"
#include "EditorTextConfig.hpp"
#include "EditorToolOption.hpp"
#include "EditorToolOptionConfig.hpp"
#include "EditorToolsViewConfig.hpp"
#include "EditorURLConfig.hpp"
#include "EditorURLPathTypeOption.hpp"
#include "EditorVideoConfig.hpp"
#include "EditorVideoCropTimeConfig.hpp"
#include "EmptyViewConfig.hpp"
#include "ExportPresetOption.hpp"
#include "FontConfig.hpp"
#include "FontFamilyOption.hpp"
#include "FontWeightOption.hpp"
#include "HybridHXPhotoPickerSpec.hpp"
#include "IndicatorTypeOption.hpp"
#include "InterfaceOrientationOption.hpp"
#include "LanguageTypeOption.hpp"
#include "LoadNetworkVideoModeOption.hpp"
#include "ModalPresentationStyleOption.hpp"
#include "NotAuthorizedConfig.hpp"
#include "PhotoAlbumControllerConfig.hpp"
#include "PhotoListAssetNumberConfig.hpp"
#include "PhotoListCameraCellConfig.hpp"
#include "PhotoListCameraTypeConfig.hpp"
#include "PhotoListCameraTypeOption.hpp"
#include "PhotoListCellConfig.hpp"
#include "PhotoListConfig.hpp"
#include "PhotoListLimitCellConfig.hpp"
#include "PhotoListSaveSystemAlbumTypeConfig.hpp"
#include "PhotoListSaveSystemAlbumTypeOption.hpp"
#include "PhotoPickerPreviewJumpStyleOption.hpp"
#include "PickerAssetOption.hpp"
#include "PickerBottomViewConfig.hpp"
#include "PickerPhotoAsset.hpp"
#include "PickerPresentStyleConfig.hpp"
#include "PickerPresentStyleOption.hpp"
#include "PickerResult.hpp"
#include "PickerSelectModeOption.hpp"
#include "PickerViewCancelPositionOption.hpp"
#include "PickerViewCancelTypeOption.hpp"
#include "PreviewPlayTypeOption.hpp"
#include "PreviewViewConfig.hpp"
#include "PreviewViewHDRMarkConfig.hpp"
#include "PreviewViewLivePhotoMarkConfig.hpp"
#include "SelectBoxConfig.hpp"
#include "SelectBoxStyleOption.hpp"
#include "SelectionTapActionOption.hpp"
#include "Size.hpp"
#include "SortOption.hpp"
#include "StatusBarStyleOption.hpp"
#include "SystemCameraConfig.hpp"
#include "SystemCameraDeviceOption.hpp"
#include "SystemCameraMediaTypeOption.hpp"
#include "SystemCameraVideoQualityOption.hpp"
#include <NitroModules/Result.hpp>
#include <exception>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <vector>

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::hxphotopicker::bridge::swift {

  // pragma MARK: std::optional<std::string>
  /**
   * Specialized version of `std::optional<std::string>`.
   */
  using std__optional_std__string_ = std::optional<std::string>;
  inline std::optional<std::string> create_std__optional_std__string_(const std::string& value) noexcept {
    return std::optional<std::string>(value);
  }
  inline bool has_value_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return optional.has_value();
  }
  inline std::string get_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<bool>
  /**
   * Specialized version of `std::optional<bool>`.
   */
  using std__optional_bool_ = std::optional<bool>;
  inline std::optional<bool> create_std__optional_bool_(const bool& value) noexcept {
    return std::optional<bool>(value);
  }
  inline bool has_value_std__optional_bool_(const std::optional<bool>& optional) noexcept {
    return optional.has_value();
  }
  inline bool get_std__optional_bool_(const std::optional<bool>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<ModalPresentationStyleOption>
  /**
   * Specialized version of `std::optional<ModalPresentationStyleOption>`.
   */
  using std__optional_ModalPresentationStyleOption_ = std::optional<ModalPresentationStyleOption>;
  inline std::optional<ModalPresentationStyleOption> create_std__optional_ModalPresentationStyleOption_(const ModalPresentationStyleOption& value) noexcept {
    return std::optional<ModalPresentationStyleOption>(value);
  }
  inline bool has_value_std__optional_ModalPresentationStyleOption_(const std::optional<ModalPresentationStyleOption>& optional) noexcept {
    return optional.has_value();
  }
  inline ModalPresentationStyleOption get_std__optional_ModalPresentationStyleOption_(const std::optional<ModalPresentationStyleOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PickerPresentStyleOption>
  /**
   * Specialized version of `std::optional<PickerPresentStyleOption>`.
   */
  using std__optional_PickerPresentStyleOption_ = std::optional<PickerPresentStyleOption>;
  inline std::optional<PickerPresentStyleOption> create_std__optional_PickerPresentStyleOption_(const PickerPresentStyleOption& value) noexcept {
    return std::optional<PickerPresentStyleOption>(value);
  }
  inline bool has_value_std__optional_PickerPresentStyleOption_(const std::optional<PickerPresentStyleOption>& optional) noexcept {
    return optional.has_value();
  }
  inline PickerPresentStyleOption get_std__optional_PickerPresentStyleOption_(const std::optional<PickerPresentStyleOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<double>
  /**
   * Specialized version of `std::optional<double>`.
   */
  using std__optional_double_ = std::optional<double>;
  inline std::optional<double> create_std__optional_double_(const double& value) noexcept {
    return std::optional<double>(value);
  }
  inline bool has_value_std__optional_double_(const std::optional<double>& optional) noexcept {
    return optional.has_value();
  }
  inline double get_std__optional_double_(const std::optional<double>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PickerPresentStyleConfig>
  /**
   * Specialized version of `std::optional<PickerPresentStyleConfig>`.
   */
  using std__optional_PickerPresentStyleConfig_ = std::optional<PickerPresentStyleConfig>;
  inline std::optional<PickerPresentStyleConfig> create_std__optional_PickerPresentStyleConfig_(const PickerPresentStyleConfig& value) noexcept {
    return std::optional<PickerPresentStyleConfig>(value);
  }
  inline bool has_value_std__optional_PickerPresentStyleConfig_(const std::optional<PickerPresentStyleConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline PickerPresentStyleConfig get_std__optional_PickerPresentStyleConfig_(const std::optional<PickerPresentStyleConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<LanguageTypeOption>
  /**
   * Specialized version of `std::optional<LanguageTypeOption>`.
   */
  using std__optional_LanguageTypeOption_ = std::optional<LanguageTypeOption>;
  inline std::optional<LanguageTypeOption> create_std__optional_LanguageTypeOption_(const LanguageTypeOption& value) noexcept {
    return std::optional<LanguageTypeOption>(value);
  }
  inline bool has_value_std__optional_LanguageTypeOption_(const std::optional<LanguageTypeOption>& optional) noexcept {
    return optional.has_value();
  }
  inline LanguageTypeOption get_std__optional_LanguageTypeOption_(const std::optional<LanguageTypeOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<AppearanceStyleOption>
  /**
   * Specialized version of `std::optional<AppearanceStyleOption>`.
   */
  using std__optional_AppearanceStyleOption_ = std::optional<AppearanceStyleOption>;
  inline std::optional<AppearanceStyleOption> create_std__optional_AppearanceStyleOption_(const AppearanceStyleOption& value) noexcept {
    return std::optional<AppearanceStyleOption>(value);
  }
  inline bool has_value_std__optional_AppearanceStyleOption_(const std::optional<AppearanceStyleOption>& optional) noexcept {
    return optional.has_value();
  }
  inline AppearanceStyleOption get_std__optional_AppearanceStyleOption_(const std::optional<AppearanceStyleOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<InterfaceOrientationOption>
  /**
   * Specialized version of `std::vector<InterfaceOrientationOption>`.
   */
  using std__vector_InterfaceOrientationOption_ = std::vector<InterfaceOrientationOption>;
  inline std::vector<InterfaceOrientationOption> create_std__vector_InterfaceOrientationOption_(size_t size) noexcept {
    std::vector<InterfaceOrientationOption> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<InterfaceOrientationOption>>
  /**
   * Specialized version of `std::optional<std::vector<InterfaceOrientationOption>>`.
   */
  using std__optional_std__vector_InterfaceOrientationOption__ = std::optional<std::vector<InterfaceOrientationOption>>;
  inline std::optional<std::vector<InterfaceOrientationOption>> create_std__optional_std__vector_InterfaceOrientationOption__(const std::vector<InterfaceOrientationOption>& value) noexcept {
    return std::optional<std::vector<InterfaceOrientationOption>>(value);
  }
  inline bool has_value_std__optional_std__vector_InterfaceOrientationOption__(const std::optional<std::vector<InterfaceOrientationOption>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<InterfaceOrientationOption> get_std__optional_std__vector_InterfaceOrientationOption__(const std::optional<std::vector<InterfaceOrientationOption>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<PickerAssetOption>
  /**
   * Specialized version of `std::vector<PickerAssetOption>`.
   */
  using std__vector_PickerAssetOption_ = std::vector<PickerAssetOption>;
  inline std::vector<PickerAssetOption> create_std__vector_PickerAssetOption_(size_t size) noexcept {
    std::vector<PickerAssetOption> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<PickerAssetOption>>
  /**
   * Specialized version of `std::optional<std::vector<PickerAssetOption>>`.
   */
  using std__optional_std__vector_PickerAssetOption__ = std::optional<std::vector<PickerAssetOption>>;
  inline std::optional<std::vector<PickerAssetOption>> create_std__optional_std__vector_PickerAssetOption__(const std::vector<PickerAssetOption>& value) noexcept {
    return std::optional<std::vector<PickerAssetOption>>(value);
  }
  inline bool has_value_std__optional_std__vector_PickerAssetOption__(const std::optional<std::vector<PickerAssetOption>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<PickerAssetOption> get_std__optional_std__vector_PickerAssetOption__(const std::optional<std::vector<PickerAssetOption>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PickerSelectModeOption>
  /**
   * Specialized version of `std::optional<PickerSelectModeOption>`.
   */
  using std__optional_PickerSelectModeOption_ = std::optional<PickerSelectModeOption>;
  inline std::optional<PickerSelectModeOption> create_std__optional_PickerSelectModeOption_(const PickerSelectModeOption& value) noexcept {
    return std::optional<PickerSelectModeOption>(value);
  }
  inline bool has_value_std__optional_PickerSelectModeOption_(const std::optional<PickerSelectModeOption>& optional) noexcept {
    return optional.has_value();
  }
  inline PickerSelectModeOption get_std__optional_PickerSelectModeOption_(const std::optional<PickerSelectModeOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<AlbumShowModeOption>
  /**
   * Specialized version of `std::optional<AlbumShowModeOption>`.
   */
  using std__optional_AlbumShowModeOption_ = std::optional<AlbumShowModeOption>;
  inline std::optional<AlbumShowModeOption> create_std__optional_AlbumShowModeOption_(const AlbumShowModeOption& value) noexcept {
    return std::optional<AlbumShowModeOption>(value);
  }
  inline bool has_value_std__optional_AlbumShowModeOption_(const std::optional<AlbumShowModeOption>& optional) noexcept {
    return optional.has_value();
  }
  inline AlbumShowModeOption get_std__optional_AlbumShowModeOption_(const std::optional<AlbumShowModeOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<AlbumShowModeConfig>
  /**
   * Specialized version of `std::optional<AlbumShowModeConfig>`.
   */
  using std__optional_AlbumShowModeConfig_ = std::optional<AlbumShowModeConfig>;
  inline std::optional<AlbumShowModeConfig> create_std__optional_AlbumShowModeConfig_(const AlbumShowModeConfig& value) noexcept {
    return std::optional<AlbumShowModeConfig>(value);
  }
  inline bool has_value_std__optional_AlbumShowModeConfig_(const std::optional<AlbumShowModeConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline AlbumShowModeConfig get_std__optional_AlbumShowModeConfig_(const std::optional<AlbumShowModeConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<SelectionTapActionOption>
  /**
   * Specialized version of `std::optional<SelectionTapActionOption>`.
   */
  using std__optional_SelectionTapActionOption_ = std::optional<SelectionTapActionOption>;
  inline std::optional<SelectionTapActionOption> create_std__optional_SelectionTapActionOption_(const SelectionTapActionOption& value) noexcept {
    return std::optional<SelectionTapActionOption>(value);
  }
  inline bool has_value_std__optional_SelectionTapActionOption_(const std::optional<SelectionTapActionOption>& optional) noexcept {
    return optional.has_value();
  }
  inline SelectionTapActionOption get_std__optional_SelectionTapActionOption_(const std::optional<SelectionTapActionOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorJumpStyleOption>
  /**
   * Specialized version of `std::optional<EditorJumpStyleOption>`.
   */
  using std__optional_EditorJumpStyleOption_ = std::optional<EditorJumpStyleOption>;
  inline std::optional<EditorJumpStyleOption> create_std__optional_EditorJumpStyleOption_(const EditorJumpStyleOption& value) noexcept {
    return std::optional<EditorJumpStyleOption>(value);
  }
  inline bool has_value_std__optional_EditorJumpStyleOption_(const std::optional<EditorJumpStyleOption>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorJumpStyleOption get_std__optional_EditorJumpStyleOption_(const std::optional<EditorJumpStyleOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorJumpPushStyleOption>
  /**
   * Specialized version of `std::optional<EditorJumpPushStyleOption>`.
   */
  using std__optional_EditorJumpPushStyleOption_ = std::optional<EditorJumpPushStyleOption>;
  inline std::optional<EditorJumpPushStyleOption> create_std__optional_EditorJumpPushStyleOption_(const EditorJumpPushStyleOption& value) noexcept {
    return std::optional<EditorJumpPushStyleOption>(value);
  }
  inline bool has_value_std__optional_EditorJumpPushStyleOption_(const std::optional<EditorJumpPushStyleOption>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorJumpPushStyleOption get_std__optional_EditorJumpPushStyleOption_(const std::optional<EditorJumpPushStyleOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorJumpPresentStyleOption>
  /**
   * Specialized version of `std::optional<EditorJumpPresentStyleOption>`.
   */
  using std__optional_EditorJumpPresentStyleOption_ = std::optional<EditorJumpPresentStyleOption>;
  inline std::optional<EditorJumpPresentStyleOption> create_std__optional_EditorJumpPresentStyleOption_(const EditorJumpPresentStyleOption& value) noexcept {
    return std::optional<EditorJumpPresentStyleOption>(value);
  }
  inline bool has_value_std__optional_EditorJumpPresentStyleOption_(const std::optional<EditorJumpPresentStyleOption>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorJumpPresentStyleOption get_std__optional_EditorJumpPresentStyleOption_(const std::optional<EditorJumpPresentStyleOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorJumpStyleConfig>
  /**
   * Specialized version of `std::optional<EditorJumpStyleConfig>`.
   */
  using std__optional_EditorJumpStyleConfig_ = std::optional<EditorJumpStyleConfig>;
  inline std::optional<EditorJumpStyleConfig> create_std__optional_EditorJumpStyleConfig_(const EditorJumpStyleConfig& value) noexcept {
    return std::optional<EditorJumpStyleConfig>(value);
  }
  inline bool has_value_std__optional_EditorJumpStyleConfig_(const std::optional<EditorJumpStyleConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorJumpStyleConfig get_std__optional_EditorJumpStyleConfig_(const std::optional<EditorJumpStyleConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorButtonTypeOption>
  /**
   * Specialized version of `std::optional<EditorButtonTypeOption>`.
   */
  using std__optional_EditorButtonTypeOption_ = std::optional<EditorButtonTypeOption>;
  inline std::optional<EditorButtonTypeOption> create_std__optional_EditorButtonTypeOption_(const EditorButtonTypeOption& value) noexcept {
    return std::optional<EditorButtonTypeOption>(value);
  }
  inline bool has_value_std__optional_EditorButtonTypeOption_(const std::optional<EditorButtonTypeOption>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorButtonTypeOption get_std__optional_EditorButtonTypeOption_(const std::optional<EditorButtonTypeOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorURLConfig>
  /**
   * Specialized version of `std::optional<EditorURLConfig>`.
   */
  using std__optional_EditorURLConfig_ = std::optional<EditorURLConfig>;
  inline std::optional<EditorURLConfig> create_std__optional_EditorURLConfig_(const EditorURLConfig& value) noexcept {
    return std::optional<EditorURLConfig>(value);
  }
  inline bool has_value_std__optional_EditorURLConfig_(const std::optional<EditorURLConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorURLConfig get_std__optional_EditorURLConfig_(const std::optional<EditorURLConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorToolOption>
  /**
   * Specialized version of `std::optional<EditorToolOption>`.
   */
  using std__optional_EditorToolOption_ = std::optional<EditorToolOption>;
  inline std::optional<EditorToolOption> create_std__optional_EditorToolOption_(const EditorToolOption& value) noexcept {
    return std::optional<EditorToolOption>(value);
  }
  inline bool has_value_std__optional_EditorToolOption_(const std::optional<EditorToolOption>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorToolOption get_std__optional_EditorToolOption_(const std::optional<EditorToolOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorFilterConfig>
  /**
   * Specialized version of `std::optional<EditorFilterConfig>`.
   */
  using std__optional_EditorFilterConfig_ = std::optional<EditorFilterConfig>;
  inline std::optional<EditorFilterConfig> create_std__optional_EditorFilterConfig_(const EditorFilterConfig& value) noexcept {
    return std::optional<EditorFilterConfig>(value);
  }
  inline bool has_value_std__optional_EditorFilterConfig_(const std::optional<EditorFilterConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorFilterConfig get_std__optional_EditorFilterConfig_(const std::optional<EditorFilterConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorPhotoConfig>
  /**
   * Specialized version of `std::optional<EditorPhotoConfig>`.
   */
  using std__optional_EditorPhotoConfig_ = std::optional<EditorPhotoConfig>;
  inline std::optional<EditorPhotoConfig> create_std__optional_EditorPhotoConfig_(const EditorPhotoConfig& value) noexcept {
    return std::optional<EditorPhotoConfig>(value);
  }
  inline bool has_value_std__optional_EditorPhotoConfig_(const std::optional<EditorPhotoConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorPhotoConfig get_std__optional_EditorPhotoConfig_(const std::optional<EditorPhotoConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<ExportPresetOption>
  /**
   * Specialized version of `std::optional<ExportPresetOption>`.
   */
  using std__optional_ExportPresetOption_ = std::optional<ExportPresetOption>;
  inline std::optional<ExportPresetOption> create_std__optional_ExportPresetOption_(const ExportPresetOption& value) noexcept {
    return std::optional<ExportPresetOption>(value);
  }
  inline bool has_value_std__optional_ExportPresetOption_(const std::optional<ExportPresetOption>& optional) noexcept {
    return optional.has_value();
  }
  inline ExportPresetOption get_std__optional_ExportPresetOption_(const std::optional<ExportPresetOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorMusicConfig>
  /**
   * Specialized version of `std::optional<EditorMusicConfig>`.
   */
  using std__optional_EditorMusicConfig_ = std::optional<EditorMusicConfig>;
  inline std::optional<EditorMusicConfig> create_std__optional_EditorMusicConfig_(const EditorMusicConfig& value) noexcept {
    return std::optional<EditorMusicConfig>(value);
  }
  inline bool has_value_std__optional_EditorMusicConfig_(const std::optional<EditorMusicConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorMusicConfig get_std__optional_EditorMusicConfig_(const std::optional<EditorMusicConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorVideoCropTimeConfig>
  /**
   * Specialized version of `std::optional<EditorVideoCropTimeConfig>`.
   */
  using std__optional_EditorVideoCropTimeConfig_ = std::optional<EditorVideoCropTimeConfig>;
  inline std::optional<EditorVideoCropTimeConfig> create_std__optional_EditorVideoCropTimeConfig_(const EditorVideoCropTimeConfig& value) noexcept {
    return std::optional<EditorVideoCropTimeConfig>(value);
  }
  inline bool has_value_std__optional_EditorVideoCropTimeConfig_(const std::optional<EditorVideoCropTimeConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorVideoCropTimeConfig get_std__optional_EditorVideoCropTimeConfig_(const std::optional<EditorVideoCropTimeConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorVideoConfig>
  /**
   * Specialized version of `std::optional<EditorVideoConfig>`.
   */
  using std__optional_EditorVideoConfig_ = std::optional<EditorVideoConfig>;
  inline std::optional<EditorVideoConfig> create_std__optional_EditorVideoConfig_(const EditorVideoConfig& value) noexcept {
    return std::optional<EditorVideoConfig>(value);
  }
  inline bool has_value_std__optional_EditorVideoConfig_(const std::optional<EditorVideoConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorVideoConfig get_std__optional_EditorVideoConfig_(const std::optional<EditorVideoConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<std::string>
  /**
   * Specialized version of `std::vector<std::string>`.
   */
  using std__vector_std__string_ = std::vector<std::string>;
  inline std::vector<std::string> create_std__vector_std__string_(size_t size) noexcept {
    std::vector<std::string> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<std::string>>
  /**
   * Specialized version of `std::optional<std::vector<std::string>>`.
   */
  using std__optional_std__vector_std__string__ = std::optional<std::vector<std::string>>;
  inline std::optional<std::vector<std::string>> create_std__optional_std__vector_std__string__(const std::vector<std::string>& value) noexcept {
    return std::optional<std::vector<std::string>>(value);
  }
  inline bool has_value_std__optional_std__vector_std__string__(const std::optional<std::vector<std::string>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<std::string> get_std__optional_std__vector_std__string__(const std::optional<std::vector<std::string>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorBrushConfig>
  /**
   * Specialized version of `std::optional<EditorBrushConfig>`.
   */
  using std__optional_EditorBrushConfig_ = std::optional<EditorBrushConfig>;
  inline std::optional<EditorBrushConfig> create_std__optional_EditorBrushConfig_(const EditorBrushConfig& value) noexcept {
    return std::optional<EditorBrushConfig>(value);
  }
  inline bool has_value_std__optional_EditorBrushConfig_(const std::optional<EditorBrushConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorBrushConfig get_std__optional_EditorBrushConfig_(const std::optional<EditorBrushConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorChartletLoadSceneOption>
  /**
   * Specialized version of `std::optional<EditorChartletLoadSceneOption>`.
   */
  using std__optional_EditorChartletLoadSceneOption_ = std::optional<EditorChartletLoadSceneOption>;
  inline std::optional<EditorChartletLoadSceneOption> create_std__optional_EditorChartletLoadSceneOption_(const EditorChartletLoadSceneOption& value) noexcept {
    return std::optional<EditorChartletLoadSceneOption>(value);
  }
  inline bool has_value_std__optional_EditorChartletLoadSceneOption_(const std::optional<EditorChartletLoadSceneOption>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorChartletLoadSceneOption get_std__optional_EditorChartletLoadSceneOption_(const std::optional<EditorChartletLoadSceneOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<EditorChartletItemConfig>
  /**
   * Specialized version of `std::vector<EditorChartletItemConfig>`.
   */
  using std__vector_EditorChartletItemConfig_ = std::vector<EditorChartletItemConfig>;
  inline std::vector<EditorChartletItemConfig> create_std__vector_EditorChartletItemConfig_(size_t size) noexcept {
    std::vector<EditorChartletItemConfig> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<EditorChartletItemConfig>>
  /**
   * Specialized version of `std::optional<std::vector<EditorChartletItemConfig>>`.
   */
  using std__optional_std__vector_EditorChartletItemConfig__ = std::optional<std::vector<EditorChartletItemConfig>>;
  inline std::optional<std::vector<EditorChartletItemConfig>> create_std__optional_std__vector_EditorChartletItemConfig__(const std::vector<EditorChartletItemConfig>& value) noexcept {
    return std::optional<std::vector<EditorChartletItemConfig>>(value);
  }
  inline bool has_value_std__optional_std__vector_EditorChartletItemConfig__(const std::optional<std::vector<EditorChartletItemConfig>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<EditorChartletItemConfig> get_std__optional_std__vector_EditorChartletItemConfig__(const std::optional<std::vector<EditorChartletItemConfig>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<std::vector<EditorChartletItemConfig>>
  /**
   * Specialized version of `std::vector<std::vector<EditorChartletItemConfig>>`.
   */
  using std__vector_std__vector_EditorChartletItemConfig__ = std::vector<std::vector<EditorChartletItemConfig>>;
  inline std::vector<std::vector<EditorChartletItemConfig>> create_std__vector_std__vector_EditorChartletItemConfig__(size_t size) noexcept {
    std::vector<std::vector<EditorChartletItemConfig>> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<std::vector<EditorChartletItemConfig>>>
  /**
   * Specialized version of `std::optional<std::vector<std::vector<EditorChartletItemConfig>>>`.
   */
  using std__optional_std__vector_std__vector_EditorChartletItemConfig___ = std::optional<std::vector<std::vector<EditorChartletItemConfig>>>;
  inline std::optional<std::vector<std::vector<EditorChartletItemConfig>>> create_std__optional_std__vector_std__vector_EditorChartletItemConfig___(const std::vector<std::vector<EditorChartletItemConfig>>& value) noexcept {
    return std::optional<std::vector<std::vector<EditorChartletItemConfig>>>(value);
  }
  inline bool has_value_std__optional_std__vector_std__vector_EditorChartletItemConfig___(const std::optional<std::vector<std::vector<EditorChartletItemConfig>>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<std::vector<EditorChartletItemConfig>> get_std__optional_std__vector_std__vector_EditorChartletItemConfig___(const std::optional<std::vector<std::vector<EditorChartletItemConfig>>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorChartletConfig>
  /**
   * Specialized version of `std::optional<EditorChartletConfig>`.
   */
  using std__optional_EditorChartletConfig_ = std::optional<EditorChartletConfig>;
  inline std::optional<EditorChartletConfig> create_std__optional_EditorChartletConfig_(const EditorChartletConfig& value) noexcept {
    return std::optional<EditorChartletConfig>(value);
  }
  inline bool has_value_std__optional_EditorChartletConfig_(const std::optional<EditorChartletConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorChartletConfig get_std__optional_EditorChartletConfig_(const std::optional<EditorChartletConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<FontWeightOption>
  /**
   * Specialized version of `std::optional<FontWeightOption>`.
   */
  using std__optional_FontWeightOption_ = std::optional<FontWeightOption>;
  inline std::optional<FontWeightOption> create_std__optional_FontWeightOption_(const FontWeightOption& value) noexcept {
    return std::optional<FontWeightOption>(value);
  }
  inline bool has_value_std__optional_FontWeightOption_(const std::optional<FontWeightOption>& optional) noexcept {
    return optional.has_value();
  }
  inline FontWeightOption get_std__optional_FontWeightOption_(const std::optional<FontWeightOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<FontFamilyOption>
  /**
   * Specialized version of `std::optional<FontFamilyOption>`.
   */
  using std__optional_FontFamilyOption_ = std::optional<FontFamilyOption>;
  inline std::optional<FontFamilyOption> create_std__optional_FontFamilyOption_(const FontFamilyOption& value) noexcept {
    return std::optional<FontFamilyOption>(value);
  }
  inline bool has_value_std__optional_FontFamilyOption_(const std::optional<FontFamilyOption>& optional) noexcept {
    return optional.has_value();
  }
  inline FontFamilyOption get_std__optional_FontFamilyOption_(const std::optional<FontFamilyOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<FontConfig>
  /**
   * Specialized version of `std::optional<FontConfig>`.
   */
  using std__optional_FontConfig_ = std::optional<FontConfig>;
  inline std::optional<FontConfig> create_std__optional_FontConfig_(const FontConfig& value) noexcept {
    return std::optional<FontConfig>(value);
  }
  inline bool has_value_std__optional_FontConfig_(const std::optional<FontConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline FontConfig get_std__optional_FontConfig_(const std::optional<FontConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorTextConfig>
  /**
   * Specialized version of `std::optional<EditorTextConfig>`.
   */
  using std__optional_EditorTextConfig_ = std::optional<EditorTextConfig>;
  inline std::optional<EditorTextConfig> create_std__optional_EditorTextConfig_(const EditorTextConfig& value) noexcept {
    return std::optional<EditorTextConfig>(value);
  }
  inline bool has_value_std__optional_EditorTextConfig_(const std::optional<EditorTextConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorTextConfig get_std__optional_EditorTextConfig_(const std::optional<EditorTextConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<Size>
  /**
   * Specialized version of `std::optional<Size>`.
   */
  using std__optional_Size_ = std::optional<Size>;
  inline std::optional<Size> create_std__optional_Size_(const Size& value) noexcept {
    return std::optional<Size>(value);
  }
  inline bool has_value_std__optional_Size_(const std::optional<Size>& optional) noexcept {
    return optional.has_value();
  }
  inline Size get_std__optional_Size_(const std::optional<Size>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorMaskTypeOption>
  /**
   * Specialized version of `std::optional<EditorMaskTypeOption>`.
   */
  using std__optional_EditorMaskTypeOption_ = std::optional<EditorMaskTypeOption>;
  inline std::optional<EditorMaskTypeOption> create_std__optional_EditorMaskTypeOption_(const EditorMaskTypeOption& value) noexcept {
    return std::optional<EditorMaskTypeOption>(value);
  }
  inline bool has_value_std__optional_EditorMaskTypeOption_(const std::optional<EditorMaskTypeOption>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorMaskTypeOption get_std__optional_EditorMaskTypeOption_(const std::optional<EditorMaskTypeOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<BlurEffectStyleOption>
  /**
   * Specialized version of `std::optional<BlurEffectStyleOption>`.
   */
  using std__optional_BlurEffectStyleOption_ = std::optional<BlurEffectStyleOption>;
  inline std::optional<BlurEffectStyleOption> create_std__optional_BlurEffectStyleOption_(const BlurEffectStyleOption& value) noexcept {
    return std::optional<BlurEffectStyleOption>(value);
  }
  inline bool has_value_std__optional_BlurEffectStyleOption_(const std::optional<BlurEffectStyleOption>& optional) noexcept {
    return optional.has_value();
  }
  inline BlurEffectStyleOption get_std__optional_BlurEffectStyleOption_(const std::optional<BlurEffectStyleOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorMaskTypeConfig>
  /**
   * Specialized version of `std::optional<EditorMaskTypeConfig>`.
   */
  using std__optional_EditorMaskTypeConfig_ = std::optional<EditorMaskTypeConfig>;
  inline std::optional<EditorMaskTypeConfig> create_std__optional_EditorMaskTypeConfig_(const EditorMaskTypeConfig& value) noexcept {
    return std::optional<EditorMaskTypeConfig>(value);
  }
  inline bool has_value_std__optional_EditorMaskTypeConfig_(const std::optional<EditorMaskTypeConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorMaskTypeConfig get_std__optional_EditorMaskTypeConfig_(const std::optional<EditorMaskTypeConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<EditorRatioConfig>
  /**
   * Specialized version of `std::vector<EditorRatioConfig>`.
   */
  using std__vector_EditorRatioConfig_ = std::vector<EditorRatioConfig>;
  inline std::vector<EditorRatioConfig> create_std__vector_EditorRatioConfig_(size_t size) noexcept {
    std::vector<EditorRatioConfig> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<EditorRatioConfig>>
  /**
   * Specialized version of `std::optional<std::vector<EditorRatioConfig>>`.
   */
  using std__optional_std__vector_EditorRatioConfig__ = std::optional<std::vector<EditorRatioConfig>>;
  inline std::optional<std::vector<EditorRatioConfig>> create_std__optional_std__vector_EditorRatioConfig__(const std::vector<EditorRatioConfig>& value) noexcept {
    return std::optional<std::vector<EditorRatioConfig>>(value);
  }
  inline bool has_value_std__optional_std__vector_EditorRatioConfig__(const std::optional<std::vector<EditorRatioConfig>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<EditorRatioConfig> get_std__optional_std__vector_EditorRatioConfig__(const std::optional<std::vector<EditorRatioConfig>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorCropSizeConfig>
  /**
   * Specialized version of `std::optional<EditorCropSizeConfig>`.
   */
  using std__optional_EditorCropSizeConfig_ = std::optional<EditorCropSizeConfig>;
  inline std::optional<EditorCropSizeConfig> create_std__optional_EditorCropSizeConfig_(const EditorCropSizeConfig& value) noexcept {
    return std::optional<EditorCropSizeConfig>(value);
  }
  inline bool has_value_std__optional_EditorCropSizeConfig_(const std::optional<EditorCropSizeConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorCropSizeConfig get_std__optional_EditorCropSizeConfig_(const std::optional<EditorCropSizeConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorMosaicConfig>
  /**
   * Specialized version of `std::optional<EditorMosaicConfig>`.
   */
  using std__optional_EditorMosaicConfig_ = std::optional<EditorMosaicConfig>;
  inline std::optional<EditorMosaicConfig> create_std__optional_EditorMosaicConfig_(const EditorMosaicConfig& value) noexcept {
    return std::optional<EditorMosaicConfig>(value);
  }
  inline bool has_value_std__optional_EditorMosaicConfig_(const std::optional<EditorMosaicConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorMosaicConfig get_std__optional_EditorMosaicConfig_(const std::optional<EditorMosaicConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<EditorToolOptionConfig>
  /**
   * Specialized version of `std::vector<EditorToolOptionConfig>`.
   */
  using std__vector_EditorToolOptionConfig_ = std::vector<EditorToolOptionConfig>;
  inline std::vector<EditorToolOptionConfig> create_std__vector_EditorToolOptionConfig_(size_t size) noexcept {
    std::vector<EditorToolOptionConfig> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<EditorToolOptionConfig>>
  /**
   * Specialized version of `std::optional<std::vector<EditorToolOptionConfig>>`.
   */
  using std__optional_std__vector_EditorToolOptionConfig__ = std::optional<std::vector<EditorToolOptionConfig>>;
  inline std::optional<std::vector<EditorToolOptionConfig>> create_std__optional_std__vector_EditorToolOptionConfig__(const std::vector<EditorToolOptionConfig>& value) noexcept {
    return std::optional<std::vector<EditorToolOptionConfig>>(value);
  }
  inline bool has_value_std__optional_std__vector_EditorToolOptionConfig__(const std::optional<std::vector<EditorToolOptionConfig>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<EditorToolOptionConfig> get_std__optional_std__vector_EditorToolOptionConfig__(const std::optional<std::vector<EditorToolOptionConfig>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorToolsViewConfig>
  /**
   * Specialized version of `std::optional<EditorToolsViewConfig>`.
   */
  using std__optional_EditorToolsViewConfig_ = std::optional<EditorToolsViewConfig>;
  inline std::optional<EditorToolsViewConfig> create_std__optional_EditorToolsViewConfig_(const EditorToolsViewConfig& value) noexcept {
    return std::optional<EditorToolsViewConfig>(value);
  }
  inline bool has_value_std__optional_EditorToolsViewConfig_(const std::optional<EditorToolsViewConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorToolsViewConfig get_std__optional_EditorToolsViewConfig_(const std::optional<EditorToolsViewConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<IndicatorTypeOption>
  /**
   * Specialized version of `std::optional<IndicatorTypeOption>`.
   */
  using std__optional_IndicatorTypeOption_ = std::optional<IndicatorTypeOption>;
  inline std::optional<IndicatorTypeOption> create_std__optional_IndicatorTypeOption_(const IndicatorTypeOption& value) noexcept {
    return std::optional<IndicatorTypeOption>(value);
  }
  inline bool has_value_std__optional_IndicatorTypeOption_(const std::optional<IndicatorTypeOption>& optional) noexcept {
    return optional.has_value();
  }
  inline IndicatorTypeOption get_std__optional_IndicatorTypeOption_(const std::optional<IndicatorTypeOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EditorConfig>
  /**
   * Specialized version of `std::optional<EditorConfig>`.
   */
  using std__optional_EditorConfig_ = std::optional<EditorConfig>;
  inline std::optional<EditorConfig> create_std__optional_EditorConfig_(const EditorConfig& value) noexcept {
    return std::optional<EditorConfig>(value);
  }
  inline bool has_value_std__optional_EditorConfig_(const std::optional<EditorConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline EditorConfig get_std__optional_EditorConfig_(const std::optional<EditorConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<StatusBarStyleOption>
  /**
   * Specialized version of `std::optional<StatusBarStyleOption>`.
   */
  using std__optional_StatusBarStyleOption_ = std::optional<StatusBarStyleOption>;
  inline std::optional<StatusBarStyleOption> create_std__optional_StatusBarStyleOption_(const StatusBarStyleOption& value) noexcept {
    return std::optional<StatusBarStyleOption>(value);
  }
  inline bool has_value_std__optional_StatusBarStyleOption_(const std::optional<StatusBarStyleOption>& optional) noexcept {
    return optional.has_value();
  }
  inline StatusBarStyleOption get_std__optional_StatusBarStyleOption_(const std::optional<StatusBarStyleOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<BarStyleOption>
  /**
   * Specialized version of `std::optional<BarStyleOption>`.
   */
  using std__optional_BarStyleOption_ = std::optional<BarStyleOption>;
  inline std::optional<BarStyleOption> create_std__optional_BarStyleOption_(const BarStyleOption& value) noexcept {
    return std::optional<BarStyleOption>(value);
  }
  inline bool has_value_std__optional_BarStyleOption_(const std::optional<BarStyleOption>& optional) noexcept {
    return optional.has_value();
  }
  inline BarStyleOption get_std__optional_BarStyleOption_(const std::optional<BarStyleOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PhotoAlbumControllerConfig>
  /**
   * Specialized version of `std::optional<PhotoAlbumControllerConfig>`.
   */
  using std__optional_PhotoAlbumControllerConfig_ = std::optional<PhotoAlbumControllerConfig>;
  inline std::optional<PhotoAlbumControllerConfig> create_std__optional_PhotoAlbumControllerConfig_(const PhotoAlbumControllerConfig& value) noexcept {
    return std::optional<PhotoAlbumControllerConfig>(value);
  }
  inline bool has_value_std__optional_PhotoAlbumControllerConfig_(const std::optional<PhotoAlbumControllerConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline PhotoAlbumControllerConfig get_std__optional_PhotoAlbumControllerConfig_(const std::optional<PhotoAlbumControllerConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<AlbumListConfig>
  /**
   * Specialized version of `std::optional<AlbumListConfig>`.
   */
  using std__optional_AlbumListConfig_ = std::optional<AlbumListConfig>;
  inline std::optional<AlbumListConfig> create_std__optional_AlbumListConfig_(const AlbumListConfig& value) noexcept {
    return std::optional<AlbumListConfig>(value);
  }
  inline bool has_value_std__optional_AlbumListConfig_(const std::optional<AlbumListConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline AlbumListConfig get_std__optional_AlbumListConfig_(const std::optional<AlbumListConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<ArrowViewConfig>
  /**
   * Specialized version of `std::optional<ArrowViewConfig>`.
   */
  using std__optional_ArrowViewConfig_ = std::optional<ArrowViewConfig>;
  inline std::optional<ArrowViewConfig> create_std__optional_ArrowViewConfig_(const ArrowViewConfig& value) noexcept {
    return std::optional<ArrowViewConfig>(value);
  }
  inline bool has_value_std__optional_ArrowViewConfig_(const std::optional<ArrowViewConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline ArrowViewConfig get_std__optional_ArrowViewConfig_(const std::optional<ArrowViewConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<AlbumTitleViewConfig>
  /**
   * Specialized version of `std::optional<AlbumTitleViewConfig>`.
   */
  using std__optional_AlbumTitleViewConfig_ = std::optional<AlbumTitleViewConfig>;
  inline std::optional<AlbumTitleViewConfig> create_std__optional_AlbumTitleViewConfig_(const AlbumTitleViewConfig& value) noexcept {
    return std::optional<AlbumTitleViewConfig>(value);
  }
  inline bool has_value_std__optional_AlbumTitleViewConfig_(const std::optional<AlbumTitleViewConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline AlbumTitleViewConfig get_std__optional_AlbumTitleViewConfig_(const std::optional<AlbumTitleViewConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<SortOption>
  /**
   * Specialized version of `std::optional<SortOption>`.
   */
  using std__optional_SortOption_ = std::optional<SortOption>;
  inline std::optional<SortOption> create_std__optional_SortOption_(const SortOption& value) noexcept {
    return std::optional<SortOption>(value);
  }
  inline bool has_value_std__optional_SortOption_(const std::optional<SortOption>& optional) noexcept {
    return optional.has_value();
  }
  inline SortOption get_std__optional_SortOption_(const std::optional<SortOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<SelectBoxStyleOption>
  /**
   * Specialized version of `std::optional<SelectBoxStyleOption>`.
   */
  using std__optional_SelectBoxStyleOption_ = std::optional<SelectBoxStyleOption>;
  inline std::optional<SelectBoxStyleOption> create_std__optional_SelectBoxStyleOption_(const SelectBoxStyleOption& value) noexcept {
    return std::optional<SelectBoxStyleOption>(value);
  }
  inline bool has_value_std__optional_SelectBoxStyleOption_(const std::optional<SelectBoxStyleOption>& optional) noexcept {
    return optional.has_value();
  }
  inline SelectBoxStyleOption get_std__optional_SelectBoxStyleOption_(const std::optional<SelectBoxStyleOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<SelectBoxConfig>
  /**
   * Specialized version of `std::optional<SelectBoxConfig>`.
   */
  using std__optional_SelectBoxConfig_ = std::optional<SelectBoxConfig>;
  inline std::optional<SelectBoxConfig> create_std__optional_SelectBoxConfig_(const SelectBoxConfig& value) noexcept {
    return std::optional<SelectBoxConfig>(value);
  }
  inline bool has_value_std__optional_SelectBoxConfig_(const std::optional<SelectBoxConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline SelectBoxConfig get_std__optional_SelectBoxConfig_(const std::optional<SelectBoxConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PhotoListCellConfig>
  /**
   * Specialized version of `std::optional<PhotoListCellConfig>`.
   */
  using std__optional_PhotoListCellConfig_ = std::optional<PhotoListCellConfig>;
  inline std::optional<PhotoListCellConfig> create_std__optional_PhotoListCellConfig_(const PhotoListCellConfig& value) noexcept {
    return std::optional<PhotoListCellConfig>(value);
  }
  inline bool has_value_std__optional_PhotoListCellConfig_(const std::optional<PhotoListCellConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline PhotoListCellConfig get_std__optional_PhotoListCellConfig_(const std::optional<PhotoListCellConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<ActivityIndicatorStyleOption>
  /**
   * Specialized version of `std::optional<ActivityIndicatorStyleOption>`.
   */
  using std__optional_ActivityIndicatorStyleOption_ = std::optional<ActivityIndicatorStyleOption>;
  inline std::optional<ActivityIndicatorStyleOption> create_std__optional_ActivityIndicatorStyleOption_(const ActivityIndicatorStyleOption& value) noexcept {
    return std::optional<ActivityIndicatorStyleOption>(value);
  }
  inline bool has_value_std__optional_ActivityIndicatorStyleOption_(const std::optional<ActivityIndicatorStyleOption>& optional) noexcept {
    return optional.has_value();
  }
  inline ActivityIndicatorStyleOption get_std__optional_ActivityIndicatorStyleOption_(const std::optional<ActivityIndicatorStyleOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PickerBottomViewConfig>
  /**
   * Specialized version of `std::optional<PickerBottomViewConfig>`.
   */
  using std__optional_PickerBottomViewConfig_ = std::optional<PickerBottomViewConfig>;
  inline std::optional<PickerBottomViewConfig> create_std__optional_PickerBottomViewConfig_(const PickerBottomViewConfig& value) noexcept {
    return std::optional<PickerBottomViewConfig>(value);
  }
  inline bool has_value_std__optional_PickerBottomViewConfig_(const std::optional<PickerBottomViewConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline PickerBottomViewConfig get_std__optional_PickerBottomViewConfig_(const std::optional<PickerBottomViewConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PhotoListCameraCellConfig>
  /**
   * Specialized version of `std::optional<PhotoListCameraCellConfig>`.
   */
  using std__optional_PhotoListCameraCellConfig_ = std::optional<PhotoListCameraCellConfig>;
  inline std::optional<PhotoListCameraCellConfig> create_std__optional_PhotoListCameraCellConfig_(const PhotoListCameraCellConfig& value) noexcept {
    return std::optional<PhotoListCameraCellConfig>(value);
  }
  inline bool has_value_std__optional_PhotoListCameraCellConfig_(const std::optional<PhotoListCameraCellConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline PhotoListCameraCellConfig get_std__optional_PhotoListCameraCellConfig_(const std::optional<PhotoListCameraCellConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PhotoListCameraTypeOption>
  /**
   * Specialized version of `std::optional<PhotoListCameraTypeOption>`.
   */
  using std__optional_PhotoListCameraTypeOption_ = std::optional<PhotoListCameraTypeOption>;
  inline std::optional<PhotoListCameraTypeOption> create_std__optional_PhotoListCameraTypeOption_(const PhotoListCameraTypeOption& value) noexcept {
    return std::optional<PhotoListCameraTypeOption>(value);
  }
  inline bool has_value_std__optional_PhotoListCameraTypeOption_(const std::optional<PhotoListCameraTypeOption>& optional) noexcept {
    return optional.has_value();
  }
  inline PhotoListCameraTypeOption get_std__optional_PhotoListCameraTypeOption_(const std::optional<PhotoListCameraTypeOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<SystemCameraMediaTypeOption>
  /**
   * Specialized version of `std::vector<SystemCameraMediaTypeOption>`.
   */
  using std__vector_SystemCameraMediaTypeOption_ = std::vector<SystemCameraMediaTypeOption>;
  inline std::vector<SystemCameraMediaTypeOption> create_std__vector_SystemCameraMediaTypeOption_(size_t size) noexcept {
    std::vector<SystemCameraMediaTypeOption> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<SystemCameraMediaTypeOption>>
  /**
   * Specialized version of `std::optional<std::vector<SystemCameraMediaTypeOption>>`.
   */
  using std__optional_std__vector_SystemCameraMediaTypeOption__ = std::optional<std::vector<SystemCameraMediaTypeOption>>;
  inline std::optional<std::vector<SystemCameraMediaTypeOption>> create_std__optional_std__vector_SystemCameraMediaTypeOption__(const std::vector<SystemCameraMediaTypeOption>& value) noexcept {
    return std::optional<std::vector<SystemCameraMediaTypeOption>>(value);
  }
  inline bool has_value_std__optional_std__vector_SystemCameraMediaTypeOption__(const std::optional<std::vector<SystemCameraMediaTypeOption>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<SystemCameraMediaTypeOption> get_std__optional_std__vector_SystemCameraMediaTypeOption__(const std::optional<std::vector<SystemCameraMediaTypeOption>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<SystemCameraVideoQualityOption>
  /**
   * Specialized version of `std::optional<SystemCameraVideoQualityOption>`.
   */
  using std__optional_SystemCameraVideoQualityOption_ = std::optional<SystemCameraVideoQualityOption>;
  inline std::optional<SystemCameraVideoQualityOption> create_std__optional_SystemCameraVideoQualityOption_(const SystemCameraVideoQualityOption& value) noexcept {
    return std::optional<SystemCameraVideoQualityOption>(value);
  }
  inline bool has_value_std__optional_SystemCameraVideoQualityOption_(const std::optional<SystemCameraVideoQualityOption>& optional) noexcept {
    return optional.has_value();
  }
  inline SystemCameraVideoQualityOption get_std__optional_SystemCameraVideoQualityOption_(const std::optional<SystemCameraVideoQualityOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<SystemCameraDeviceOption>
  /**
   * Specialized version of `std::optional<SystemCameraDeviceOption>`.
   */
  using std__optional_SystemCameraDeviceOption_ = std::optional<SystemCameraDeviceOption>;
  inline std::optional<SystemCameraDeviceOption> create_std__optional_SystemCameraDeviceOption_(const SystemCameraDeviceOption& value) noexcept {
    return std::optional<SystemCameraDeviceOption>(value);
  }
  inline bool has_value_std__optional_SystemCameraDeviceOption_(const std::optional<SystemCameraDeviceOption>& optional) noexcept {
    return optional.has_value();
  }
  inline SystemCameraDeviceOption get_std__optional_SystemCameraDeviceOption_(const std::optional<SystemCameraDeviceOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<SystemCameraConfig>
  /**
   * Specialized version of `std::optional<SystemCameraConfig>`.
   */
  using std__optional_SystemCameraConfig_ = std::optional<SystemCameraConfig>;
  inline std::optional<SystemCameraConfig> create_std__optional_SystemCameraConfig_(const SystemCameraConfig& value) noexcept {
    return std::optional<SystemCameraConfig>(value);
  }
  inline bool has_value_std__optional_SystemCameraConfig_(const std::optional<SystemCameraConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline SystemCameraConfig get_std__optional_SystemCameraConfig_(const std::optional<SystemCameraConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PhotoListSaveSystemAlbumTypeOption>
  /**
   * Specialized version of `std::optional<PhotoListSaveSystemAlbumTypeOption>`.
   */
  using std__optional_PhotoListSaveSystemAlbumTypeOption_ = std::optional<PhotoListSaveSystemAlbumTypeOption>;
  inline std::optional<PhotoListSaveSystemAlbumTypeOption> create_std__optional_PhotoListSaveSystemAlbumTypeOption_(const PhotoListSaveSystemAlbumTypeOption& value) noexcept {
    return std::optional<PhotoListSaveSystemAlbumTypeOption>(value);
  }
  inline bool has_value_std__optional_PhotoListSaveSystemAlbumTypeOption_(const std::optional<PhotoListSaveSystemAlbumTypeOption>& optional) noexcept {
    return optional.has_value();
  }
  inline PhotoListSaveSystemAlbumTypeOption get_std__optional_PhotoListSaveSystemAlbumTypeOption_(const std::optional<PhotoListSaveSystemAlbumTypeOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PhotoListSaveSystemAlbumTypeConfig>
  /**
   * Specialized version of `std::optional<PhotoListSaveSystemAlbumTypeConfig>`.
   */
  using std__optional_PhotoListSaveSystemAlbumTypeConfig_ = std::optional<PhotoListSaveSystemAlbumTypeConfig>;
  inline std::optional<PhotoListSaveSystemAlbumTypeConfig> create_std__optional_PhotoListSaveSystemAlbumTypeConfig_(const PhotoListSaveSystemAlbumTypeConfig& value) noexcept {
    return std::optional<PhotoListSaveSystemAlbumTypeConfig>(value);
  }
  inline bool has_value_std__optional_PhotoListSaveSystemAlbumTypeConfig_(const std::optional<PhotoListSaveSystemAlbumTypeConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline PhotoListSaveSystemAlbumTypeConfig get_std__optional_PhotoListSaveSystemAlbumTypeConfig_(const std::optional<PhotoListSaveSystemAlbumTypeConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<CameraPresetOption>
  /**
   * Specialized version of `std::optional<CameraPresetOption>`.
   */
  using std__optional_CameraPresetOption_ = std::optional<CameraPresetOption>;
  inline std::optional<CameraPresetOption> create_std__optional_CameraPresetOption_(const CameraPresetOption& value) noexcept {
    return std::optional<CameraPresetOption>(value);
  }
  inline bool has_value_std__optional_CameraPresetOption_(const std::optional<CameraPresetOption>& optional) noexcept {
    return optional.has_value();
  }
  inline CameraPresetOption get_std__optional_CameraPresetOption_(const std::optional<CameraPresetOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<CameraAspectRatioOption>
  /**
   * Specialized version of `std::optional<CameraAspectRatioOption>`.
   */
  using std__optional_CameraAspectRatioOption_ = std::optional<CameraAspectRatioOption>;
  inline std::optional<CameraAspectRatioOption> create_std__optional_CameraAspectRatioOption_(const CameraAspectRatioOption& value) noexcept {
    return std::optional<CameraAspectRatioOption>(value);
  }
  inline bool has_value_std__optional_CameraAspectRatioOption_(const std::optional<CameraAspectRatioOption>& optional) noexcept {
    return optional.has_value();
  }
  inline CameraAspectRatioOption get_std__optional_CameraAspectRatioOption_(const std::optional<CameraAspectRatioOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<CameraAspectRatioConfig>
  /**
   * Specialized version of `std::optional<CameraAspectRatioConfig>`.
   */
  using std__optional_CameraAspectRatioConfig_ = std::optional<CameraAspectRatioConfig>;
  inline std::optional<CameraAspectRatioConfig> create_std__optional_CameraAspectRatioConfig_(const CameraAspectRatioConfig& value) noexcept {
    return std::optional<CameraAspectRatioConfig>(value);
  }
  inline bool has_value_std__optional_CameraAspectRatioConfig_(const std::optional<CameraAspectRatioConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline CameraAspectRatioConfig get_std__optional_CameraAspectRatioConfig_(const std::optional<CameraAspectRatioConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<CameraDevicePositionOption>
  /**
   * Specialized version of `std::optional<CameraDevicePositionOption>`.
   */
  using std__optional_CameraDevicePositionOption_ = std::optional<CameraDevicePositionOption>;
  inline std::optional<CameraDevicePositionOption> create_std__optional_CameraDevicePositionOption_(const CameraDevicePositionOption& value) noexcept {
    return std::optional<CameraDevicePositionOption>(value);
  }
  inline bool has_value_std__optional_CameraDevicePositionOption_(const std::optional<CameraDevicePositionOption>& optional) noexcept {
    return optional.has_value();
  }
  inline CameraDevicePositionOption get_std__optional_CameraDevicePositionOption_(const std::optional<CameraDevicePositionOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<CameraFlashModeOption>
  /**
   * Specialized version of `std::optional<CameraFlashModeOption>`.
   */
  using std__optional_CameraFlashModeOption_ = std::optional<CameraFlashModeOption>;
  inline std::optional<CameraFlashModeOption> create_std__optional_CameraFlashModeOption_(const CameraFlashModeOption& value) noexcept {
    return std::optional<CameraFlashModeOption>(value);
  }
  inline bool has_value_std__optional_CameraFlashModeOption_(const std::optional<CameraFlashModeOption>& optional) noexcept {
    return optional.has_value();
  }
  inline CameraFlashModeOption get_std__optional_CameraFlashModeOption_(const std::optional<CameraFlashModeOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<CameraVideoCodecTypeOption>
  /**
   * Specialized version of `std::optional<CameraVideoCodecTypeOption>`.
   */
  using std__optional_CameraVideoCodecTypeOption_ = std::optional<CameraVideoCodecTypeOption>;
  inline std::optional<CameraVideoCodecTypeOption> create_std__optional_CameraVideoCodecTypeOption_(const CameraVideoCodecTypeOption& value) noexcept {
    return std::optional<CameraVideoCodecTypeOption>(value);
  }
  inline bool has_value_std__optional_CameraVideoCodecTypeOption_(const std::optional<CameraVideoCodecTypeOption>& optional) noexcept {
    return optional.has_value();
  }
  inline CameraVideoCodecTypeOption get_std__optional_CameraVideoCodecTypeOption_(const std::optional<CameraVideoCodecTypeOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<CameraTakePhotoModeOption>
  /**
   * Specialized version of `std::optional<CameraTakePhotoModeOption>`.
   */
  using std__optional_CameraTakePhotoModeOption_ = std::optional<CameraTakePhotoModeOption>;
  inline std::optional<CameraTakePhotoModeOption> create_std__optional_CameraTakePhotoModeOption_(const CameraTakePhotoModeOption& value) noexcept {
    return std::optional<CameraTakePhotoModeOption>(value);
  }
  inline bool has_value_std__optional_CameraTakePhotoModeOption_(const std::optional<CameraTakePhotoModeOption>& optional) noexcept {
    return optional.has_value();
  }
  inline CameraTakePhotoModeOption get_std__optional_CameraTakePhotoModeOption_(const std::optional<CameraTakePhotoModeOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<CameraConfig>
  /**
   * Specialized version of `std::optional<CameraConfig>`.
   */
  using std__optional_CameraConfig_ = std::optional<CameraConfig>;
  inline std::optional<CameraConfig> create_std__optional_CameraConfig_(const CameraConfig& value) noexcept {
    return std::optional<CameraConfig>(value);
  }
  inline bool has_value_std__optional_CameraConfig_(const std::optional<CameraConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline CameraConfig get_std__optional_CameraConfig_(const std::optional<CameraConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PhotoListCameraTypeConfig>
  /**
   * Specialized version of `std::optional<PhotoListCameraTypeConfig>`.
   */
  using std__optional_PhotoListCameraTypeConfig_ = std::optional<PhotoListCameraTypeConfig>;
  inline std::optional<PhotoListCameraTypeConfig> create_std__optional_PhotoListCameraTypeConfig_(const PhotoListCameraTypeConfig& value) noexcept {
    return std::optional<PhotoListCameraTypeConfig>(value);
  }
  inline bool has_value_std__optional_PhotoListCameraTypeConfig_(const std::optional<PhotoListCameraTypeConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline PhotoListCameraTypeConfig get_std__optional_PhotoListCameraTypeConfig_(const std::optional<PhotoListCameraTypeConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PhotoListLimitCellConfig>
  /**
   * Specialized version of `std::optional<PhotoListLimitCellConfig>`.
   */
  using std__optional_PhotoListLimitCellConfig_ = std::optional<PhotoListLimitCellConfig>;
  inline std::optional<PhotoListLimitCellConfig> create_std__optional_PhotoListLimitCellConfig_(const PhotoListLimitCellConfig& value) noexcept {
    return std::optional<PhotoListLimitCellConfig>(value);
  }
  inline bool has_value_std__optional_PhotoListLimitCellConfig_(const std::optional<PhotoListLimitCellConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline PhotoListLimitCellConfig get_std__optional_PhotoListLimitCellConfig_(const std::optional<PhotoListLimitCellConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PhotoListAssetNumberConfig>
  /**
   * Specialized version of `std::optional<PhotoListAssetNumberConfig>`.
   */
  using std__optional_PhotoListAssetNumberConfig_ = std::optional<PhotoListAssetNumberConfig>;
  inline std::optional<PhotoListAssetNumberConfig> create_std__optional_PhotoListAssetNumberConfig_(const PhotoListAssetNumberConfig& value) noexcept {
    return std::optional<PhotoListAssetNumberConfig>(value);
  }
  inline bool has_value_std__optional_PhotoListAssetNumberConfig_(const std::optional<PhotoListAssetNumberConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline PhotoListAssetNumberConfig get_std__optional_PhotoListAssetNumberConfig_(const std::optional<PhotoListAssetNumberConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EmptyViewConfig>
  /**
   * Specialized version of `std::optional<EmptyViewConfig>`.
   */
  using std__optional_EmptyViewConfig_ = std::optional<EmptyViewConfig>;
  inline std::optional<EmptyViewConfig> create_std__optional_EmptyViewConfig_(const EmptyViewConfig& value) noexcept {
    return std::optional<EmptyViewConfig>(value);
  }
  inline bool has_value_std__optional_EmptyViewConfig_(const std::optional<EmptyViewConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline EmptyViewConfig get_std__optional_EmptyViewConfig_(const std::optional<EmptyViewConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PhotoPickerPreviewJumpStyleOption>
  /**
   * Specialized version of `std::optional<PhotoPickerPreviewJumpStyleOption>`.
   */
  using std__optional_PhotoPickerPreviewJumpStyleOption_ = std::optional<PhotoPickerPreviewJumpStyleOption>;
  inline std::optional<PhotoPickerPreviewJumpStyleOption> create_std__optional_PhotoPickerPreviewJumpStyleOption_(const PhotoPickerPreviewJumpStyleOption& value) noexcept {
    return std::optional<PhotoPickerPreviewJumpStyleOption>(value);
  }
  inline bool has_value_std__optional_PhotoPickerPreviewJumpStyleOption_(const std::optional<PhotoPickerPreviewJumpStyleOption>& optional) noexcept {
    return optional.has_value();
  }
  inline PhotoPickerPreviewJumpStyleOption get_std__optional_PhotoPickerPreviewJumpStyleOption_(const std::optional<PhotoPickerPreviewJumpStyleOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PhotoListConfig>
  /**
   * Specialized version of `std::optional<PhotoListConfig>`.
   */
  using std__optional_PhotoListConfig_ = std::optional<PhotoListConfig>;
  inline std::optional<PhotoListConfig> create_std__optional_PhotoListConfig_(const PhotoListConfig& value) noexcept {
    return std::optional<PhotoListConfig>(value);
  }
  inline bool has_value_std__optional_PhotoListConfig_(const std::optional<PhotoListConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline PhotoListConfig get_std__optional_PhotoListConfig_(const std::optional<PhotoListConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<LoadNetworkVideoModeOption>
  /**
   * Specialized version of `std::optional<LoadNetworkVideoModeOption>`.
   */
  using std__optional_LoadNetworkVideoModeOption_ = std::optional<LoadNetworkVideoModeOption>;
  inline std::optional<LoadNetworkVideoModeOption> create_std__optional_LoadNetworkVideoModeOption_(const LoadNetworkVideoModeOption& value) noexcept {
    return std::optional<LoadNetworkVideoModeOption>(value);
  }
  inline bool has_value_std__optional_LoadNetworkVideoModeOption_(const std::optional<LoadNetworkVideoModeOption>& optional) noexcept {
    return optional.has_value();
  }
  inline LoadNetworkVideoModeOption get_std__optional_LoadNetworkVideoModeOption_(const std::optional<LoadNetworkVideoModeOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PreviewPlayTypeOption>
  /**
   * Specialized version of `std::optional<PreviewPlayTypeOption>`.
   */
  using std__optional_PreviewPlayTypeOption_ = std::optional<PreviewPlayTypeOption>;
  inline std::optional<PreviewPlayTypeOption> create_std__optional_PreviewPlayTypeOption_(const PreviewPlayTypeOption& value) noexcept {
    return std::optional<PreviewPlayTypeOption>(value);
  }
  inline bool has_value_std__optional_PreviewPlayTypeOption_(const std::optional<PreviewPlayTypeOption>& optional) noexcept {
    return optional.has_value();
  }
  inline PreviewPlayTypeOption get_std__optional_PreviewPlayTypeOption_(const std::optional<PreviewPlayTypeOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PreviewViewLivePhotoMarkConfig>
  /**
   * Specialized version of `std::optional<PreviewViewLivePhotoMarkConfig>`.
   */
  using std__optional_PreviewViewLivePhotoMarkConfig_ = std::optional<PreviewViewLivePhotoMarkConfig>;
  inline std::optional<PreviewViewLivePhotoMarkConfig> create_std__optional_PreviewViewLivePhotoMarkConfig_(const PreviewViewLivePhotoMarkConfig& value) noexcept {
    return std::optional<PreviewViewLivePhotoMarkConfig>(value);
  }
  inline bool has_value_std__optional_PreviewViewLivePhotoMarkConfig_(const std::optional<PreviewViewLivePhotoMarkConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline PreviewViewLivePhotoMarkConfig get_std__optional_PreviewViewLivePhotoMarkConfig_(const std::optional<PreviewViewLivePhotoMarkConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PreviewViewHDRMarkConfig>
  /**
   * Specialized version of `std::optional<PreviewViewHDRMarkConfig>`.
   */
  using std__optional_PreviewViewHDRMarkConfig_ = std::optional<PreviewViewHDRMarkConfig>;
  inline std::optional<PreviewViewHDRMarkConfig> create_std__optional_PreviewViewHDRMarkConfig_(const PreviewViewHDRMarkConfig& value) noexcept {
    return std::optional<PreviewViewHDRMarkConfig>(value);
  }
  inline bool has_value_std__optional_PreviewViewHDRMarkConfig_(const std::optional<PreviewViewHDRMarkConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline PreviewViewHDRMarkConfig get_std__optional_PreviewViewHDRMarkConfig_(const std::optional<PreviewViewHDRMarkConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PickerViewCancelTypeOption>
  /**
   * Specialized version of `std::optional<PickerViewCancelTypeOption>`.
   */
  using std__optional_PickerViewCancelTypeOption_ = std::optional<PickerViewCancelTypeOption>;
  inline std::optional<PickerViewCancelTypeOption> create_std__optional_PickerViewCancelTypeOption_(const PickerViewCancelTypeOption& value) noexcept {
    return std::optional<PickerViewCancelTypeOption>(value);
  }
  inline bool has_value_std__optional_PickerViewCancelTypeOption_(const std::optional<PickerViewCancelTypeOption>& optional) noexcept {
    return optional.has_value();
  }
  inline PickerViewCancelTypeOption get_std__optional_PickerViewCancelTypeOption_(const std::optional<PickerViewCancelTypeOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PickerViewCancelPositionOption>
  /**
   * Specialized version of `std::optional<PickerViewCancelPositionOption>`.
   */
  using std__optional_PickerViewCancelPositionOption_ = std::optional<PickerViewCancelPositionOption>;
  inline std::optional<PickerViewCancelPositionOption> create_std__optional_PickerViewCancelPositionOption_(const PickerViewCancelPositionOption& value) noexcept {
    return std::optional<PickerViewCancelPositionOption>(value);
  }
  inline bool has_value_std__optional_PickerViewCancelPositionOption_(const std::optional<PickerViewCancelPositionOption>& optional) noexcept {
    return optional.has_value();
  }
  inline PickerViewCancelPositionOption get_std__optional_PickerViewCancelPositionOption_(const std::optional<PickerViewCancelPositionOption>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<PreviewViewConfig>
  /**
   * Specialized version of `std::optional<PreviewViewConfig>`.
   */
  using std__optional_PreviewViewConfig_ = std::optional<PreviewViewConfig>;
  inline std::optional<PreviewViewConfig> create_std__optional_PreviewViewConfig_(const PreviewViewConfig& value) noexcept {
    return std::optional<PreviewViewConfig>(value);
  }
  inline bool has_value_std__optional_PreviewViewConfig_(const std::optional<PreviewViewConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline PreviewViewConfig get_std__optional_PreviewViewConfig_(const std::optional<PreviewViewConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<NotAuthorizedConfig>
  /**
   * Specialized version of `std::optional<NotAuthorizedConfig>`.
   */
  using std__optional_NotAuthorizedConfig_ = std::optional<NotAuthorizedConfig>;
  inline std::optional<NotAuthorizedConfig> create_std__optional_NotAuthorizedConfig_(const NotAuthorizedConfig& value) noexcept {
    return std::optional<NotAuthorizedConfig>(value);
  }
  inline bool has_value_std__optional_NotAuthorizedConfig_(const std::optional<NotAuthorizedConfig>& optional) noexcept {
    return optional.has_value();
  }
  inline NotAuthorizedConfig get_std__optional_NotAuthorizedConfig_(const std::optional<NotAuthorizedConfig>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<PickerPhotoAsset>
  /**
   * Specialized version of `std::vector<PickerPhotoAsset>`.
   */
  using std__vector_PickerPhotoAsset_ = std::vector<PickerPhotoAsset>;
  inline std::vector<PickerPhotoAsset> create_std__vector_PickerPhotoAsset_(size_t size) noexcept {
    std::vector<PickerPhotoAsset> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::function<void(const PickerResult& /* result */)>
  /**
   * Specialized version of `std::function<void(const PickerResult&)>`.
   */
  using Func_void_PickerResult = std::function<void(const PickerResult& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const PickerResult& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_PickerResult_Wrapper final {
  public:
    explicit Func_void_PickerResult_Wrapper(std::function<void(const PickerResult& /* result */)>&& func): _function(std::make_unique<std::function<void(const PickerResult& /* result */)>>(std::move(func))) {}
    inline void call(PickerResult result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const PickerResult& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_PickerResult create_Func_void_PickerResult(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_PickerResult_Wrapper wrap_Func_void_PickerResult(Func_void_PickerResult value) noexcept {
    return Func_void_PickerResult_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void()>
  /**
   * Specialized version of `std::function<void()>`.
   */
  using Func_void = std::function<void()>;
  /**
   * Wrapper class for a `std::function<void()>`, this can be used from Swift.
   */
  class Func_void_Wrapper final {
  public:
    explicit Func_void_Wrapper(std::function<void()>&& func): _function(std::make_unique<std::function<void()>>(std::move(func))) {}
    inline void call() const noexcept {
      _function->operator()();
    }
  private:
    std::unique_ptr<std::function<void()>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void create_Func_void(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_Wrapper wrap_Func_void(Func_void value) noexcept {
    return Func_void_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<HybridHXPhotoPickerSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridHXPhotoPickerSpec>`.
   */
  using std__shared_ptr_HybridHXPhotoPickerSpec_ = std::shared_ptr<HybridHXPhotoPickerSpec>;
  std::shared_ptr<HybridHXPhotoPickerSpec> create_std__shared_ptr_HybridHXPhotoPickerSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridHXPhotoPickerSpec_(std__shared_ptr_HybridHXPhotoPickerSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridHXPhotoPickerSpec>
  using std__weak_ptr_HybridHXPhotoPickerSpec_ = std::weak_ptr<HybridHXPhotoPickerSpec>;
  inline std__weak_ptr_HybridHXPhotoPickerSpec_ weakify_std__shared_ptr_HybridHXPhotoPickerSpec_(const std::shared_ptr<HybridHXPhotoPickerSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<void>
  using Result_void_ = Result<void>;
  inline Result_void_ create_Result_void_() noexcept {
    return Result<void>::withValue();
  }
  inline Result_void_ create_Result_void_(const std::exception_ptr& error) noexcept {
    return Result<void>::withError(error);
  }

} // namespace margelo::nitro::hxphotopicker::bridge::swift
