///
/// CameraConfig.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

import Foundation
import NitroModules

/**
 * Represents an instance of `CameraConfig`, backed by a C++ struct.
 */
public typealias CameraConfig = margelo.nitro.hxphotopicker.CameraConfig

public extension CameraConfig {
  private typealias bridge = margelo.nitro.hxphotopicker.bridge.swift

  /**
   * Create a new instance of `CameraConfig`.
   */
  init(modalPresentationStyle: ModalPresentationStyleOption?, languageType: LanguageTypeOption?, prefersStatusBarHidden: Bool?, shouldAutorotate: Bool?, isAutoBack: Bool?, supportedInterfaceOrientations: [InterfaceOrientationOption]?, indicatorType: IndicatorTypeOption?, isSaveSystemAlbum: Bool?, saveSystemAlbumType: PhotoListSaveSystemAlbumTypeConfig?, sessionPreset: CameraPresetOption?, aspectRatio: CameraAspectRatioConfig?, position: CameraDevicePositionOption?, flashMode: CameraFlashModeOption?, videoCodecType: CameraVideoCodecTypeOption?, videoMaximumDuration: Double?, videoMinimumDuration: Double?, takePhotoMode: CameraTakePhotoModeOption?, tintColor: String?, focusColor: String?, videoMaxZoomScale: Double?, allowsEditing: Bool?, allowLocation: Bool?) {
    self.init({ () -> bridge.std__optional_ModalPresentationStyleOption_ in
      if let __unwrappedValue = modalPresentationStyle {
        return bridge.create_std__optional_ModalPresentationStyleOption_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_LanguageTypeOption_ in
      if let __unwrappedValue = languageType {
        return bridge.create_std__optional_LanguageTypeOption_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = prefersStatusBarHidden {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = shouldAutorotate {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = isAutoBack {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__vector_InterfaceOrientationOption__ in
      if let __unwrappedValue = supportedInterfaceOrientations {
        return bridge.create_std__optional_std__vector_InterfaceOrientationOption__({ () -> bridge.std__vector_InterfaceOrientationOption_ in
          var __vector = bridge.create_std__vector_InterfaceOrientationOption_(__unwrappedValue.count)
          for __item in __unwrappedValue {
            __vector.push_back(__item)
          }
          return __vector
        }())
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_IndicatorTypeOption_ in
      if let __unwrappedValue = indicatorType {
        return bridge.create_std__optional_IndicatorTypeOption_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = isSaveSystemAlbum {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_PhotoListSaveSystemAlbumTypeConfig_ in
      if let __unwrappedValue = saveSystemAlbumType {
        return bridge.create_std__optional_PhotoListSaveSystemAlbumTypeConfig_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_CameraPresetOption_ in
      if let __unwrappedValue = sessionPreset {
        return bridge.create_std__optional_CameraPresetOption_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_CameraAspectRatioConfig_ in
      if let __unwrappedValue = aspectRatio {
        return bridge.create_std__optional_CameraAspectRatioConfig_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_CameraDevicePositionOption_ in
      if let __unwrappedValue = position {
        return bridge.create_std__optional_CameraDevicePositionOption_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_CameraFlashModeOption_ in
      if let __unwrappedValue = flashMode {
        return bridge.create_std__optional_CameraFlashModeOption_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_CameraVideoCodecTypeOption_ in
      if let __unwrappedValue = videoCodecType {
        return bridge.create_std__optional_CameraVideoCodecTypeOption_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = videoMaximumDuration {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = videoMinimumDuration {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_CameraTakePhotoModeOption_ in
      if let __unwrappedValue = takePhotoMode {
        return bridge.create_std__optional_CameraTakePhotoModeOption_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = tintColor {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = focusColor {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = videoMaxZoomScale {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = allowsEditing {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = allowLocation {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }())
  }

  @inline(__always)
  var modalPresentationStyle: ModalPresentationStyleOption? {
    return self.__modalPresentationStyle.value
  }
  
  @inline(__always)
  var languageType: LanguageTypeOption? {
    return self.__languageType.value
  }
  
  @inline(__always)
  var prefersStatusBarHidden: Bool? {
    return { () -> Bool? in
      if bridge.has_value_std__optional_bool_(self.__prefersStatusBarHidden) {
        let __unwrapped = bridge.get_std__optional_bool_(self.__prefersStatusBarHidden)
        return __unwrapped
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var shouldAutorotate: Bool? {
    return { () -> Bool? in
      if bridge.has_value_std__optional_bool_(self.__shouldAutorotate) {
        let __unwrapped = bridge.get_std__optional_bool_(self.__shouldAutorotate)
        return __unwrapped
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var isAutoBack: Bool? {
    return { () -> Bool? in
      if bridge.has_value_std__optional_bool_(self.__isAutoBack) {
        let __unwrapped = bridge.get_std__optional_bool_(self.__isAutoBack)
        return __unwrapped
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var supportedInterfaceOrientations: [InterfaceOrientationOption]? {
    return { () -> [InterfaceOrientationOption]? in
      if bridge.has_value_std__optional_std__vector_InterfaceOrientationOption__(self.__supportedInterfaceOrientations) {
        let __unwrapped = bridge.get_std__optional_std__vector_InterfaceOrientationOption__(self.__supportedInterfaceOrientations)
        return __unwrapped.map({ __item in __item })
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var indicatorType: IndicatorTypeOption? {
    return self.__indicatorType.value
  }
  
  @inline(__always)
  var isSaveSystemAlbum: Bool? {
    return { () -> Bool? in
      if bridge.has_value_std__optional_bool_(self.__isSaveSystemAlbum) {
        let __unwrapped = bridge.get_std__optional_bool_(self.__isSaveSystemAlbum)
        return __unwrapped
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var saveSystemAlbumType: PhotoListSaveSystemAlbumTypeConfig? {
    return self.__saveSystemAlbumType.value
  }
  
  @inline(__always)
  var sessionPreset: CameraPresetOption? {
    return self.__sessionPreset.value
  }
  
  @inline(__always)
  var aspectRatio: CameraAspectRatioConfig? {
    return self.__aspectRatio.value
  }
  
  @inline(__always)
  var position: CameraDevicePositionOption? {
    return self.__position.value
  }
  
  @inline(__always)
  var flashMode: CameraFlashModeOption? {
    return self.__flashMode.value
  }
  
  @inline(__always)
  var videoCodecType: CameraVideoCodecTypeOption? {
    return self.__videoCodecType.value
  }
  
  @inline(__always)
  var videoMaximumDuration: Double? {
    return self.__videoMaximumDuration.value
  }
  
  @inline(__always)
  var videoMinimumDuration: Double? {
    return self.__videoMinimumDuration.value
  }
  
  @inline(__always)
  var takePhotoMode: CameraTakePhotoModeOption? {
    return self.__takePhotoMode.value
  }
  
  @inline(__always)
  var tintColor: String? {
    return { () -> String? in
      if bridge.has_value_std__optional_std__string_(self.__tintColor) {
        let __unwrapped = bridge.get_std__optional_std__string_(self.__tintColor)
        return String(__unwrapped)
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var focusColor: String? {
    return { () -> String? in
      if bridge.has_value_std__optional_std__string_(self.__focusColor) {
        let __unwrapped = bridge.get_std__optional_std__string_(self.__focusColor)
        return String(__unwrapped)
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var videoMaxZoomScale: Double? {
    return self.__videoMaxZoomScale.value
  }
  
  @inline(__always)
  var allowsEditing: Bool? {
    return { () -> Bool? in
      if bridge.has_value_std__optional_bool_(self.__allowsEditing) {
        let __unwrapped = bridge.get_std__optional_bool_(self.__allowsEditing)
        return __unwrapped
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var allowLocation: Bool? {
    return { () -> Bool? in
      if bridge.has_value_std__optional_bool_(self.__allowLocation) {
        let __unwrapped = bridge.get_std__optional_bool_(self.__allowLocation)
        return __unwrapped
      } else {
        return nil
      }
    }()
  }
}
