///
/// PhotoListConfig.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#pragma once

#if __has_include(<NitroModules/JSIConverter.hpp>)
#include <NitroModules/JSIConverter.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/NitroDefines.hpp>)
#include <NitroModules/NitroDefines.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/JSIHelpers.hpp>)
#include <NitroModules/JSIHelpers.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/PropNameIDCache.hpp>)
#include <NitroModules/PropNameIDCache.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif

// Forward declaration of `AlbumTitleViewConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct AlbumTitleViewConfig; }
// Forward declaration of `SortOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class SortOption; }
// Forward declaration of `PhotoListCellConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PhotoListCellConfig; }
// Forward declaration of `PickerBottomViewConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PickerBottomViewConfig; }
// Forward declaration of `PhotoListCameraCellConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PhotoListCameraCellConfig; }
// Forward declaration of `PhotoListCameraTypeConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PhotoListCameraTypeConfig; }
// Forward declaration of `PhotoListSaveSystemAlbumTypeConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PhotoListSaveSystemAlbumTypeConfig; }
// Forward declaration of `PhotoListLimitCellConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PhotoListLimitCellConfig; }
// Forward declaration of `PhotoListAssetNumberConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct PhotoListAssetNumberConfig; }
// Forward declaration of `EmptyViewConfig` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { struct EmptyViewConfig; }
// Forward declaration of `PhotoPickerPreviewJumpStyleOption` to properly resolve imports.
namespace margelo::nitro::hxphotopicker { enum class PhotoPickerPreviewJumpStyleOption; }

#include "AlbumTitleViewConfig.hpp"
#include <optional>
#include "SortOption.hpp"
#include <string>
#include "PhotoListCellConfig.hpp"
#include "PickerBottomViewConfig.hpp"
#include "PhotoListCameraCellConfig.hpp"
#include "PhotoListCameraTypeConfig.hpp"
#include "PhotoListSaveSystemAlbumTypeConfig.hpp"
#include "PhotoListLimitCellConfig.hpp"
#include "PhotoListAssetNumberConfig.hpp"
#include "EmptyViewConfig.hpp"
#include "PhotoPickerPreviewJumpStyleOption.hpp"

namespace margelo::nitro::hxphotopicker {

  /**
   * A struct which can be represented as a JavaScript object (PhotoListConfig).
   */
  struct PhotoListConfig final {
  public:
    std::optional<AlbumTitleViewConfig> titleView     SWIFT_PRIVATE;
    std::optional<SortOption> sort     SWIFT_PRIVATE;
    std::optional<std::string> backgroundColor     SWIFT_PRIVATE;
    std::optional<std::string> backgroundDarkColor     SWIFT_PRIVATE;
    std::optional<std::string> cancelImageName     SWIFT_PRIVATE;
    std::optional<std::string> cancelDarkImageName     SWIFT_PRIVATE;
    std::optional<bool> isShowFilterItem     SWIFT_PRIVATE;
    std::optional<std::string> filterThemeColor     SWIFT_PRIVATE;
    std::optional<std::string> filterThemeDarkColor     SWIFT_PRIVATE;
    std::optional<double> rowNumber     SWIFT_PRIVATE;
    std::optional<double> landscapeRowNumber     SWIFT_PRIVATE;
    std::optional<double> spltRowNumber     SWIFT_PRIVATE;
    std::optional<double> spacing     SWIFT_PRIVATE;
    std::optional<bool> allowHapticTouchPreview     SWIFT_PRIVATE;
    std::optional<bool> allowAddMenuElements     SWIFT_PRIVATE;
    std::optional<bool> allowSwipeToSelect     SWIFT_PRIVATE;
    std::optional<bool> swipeSelectAllowAutoScroll     SWIFT_PRIVATE;
    std::optional<double> swipeSelectIgnoreLeftArea     SWIFT_PRIVATE;
    std::optional<double> swipeSelectScrollSpeed     SWIFT_PRIVATE;
    std::optional<double> autoSwipeTopAreaHeight     SWIFT_PRIVATE;
    std::optional<double> autoSwipeBottomAreaHeight     SWIFT_PRIVATE;
    std::optional<PhotoListCellConfig> cell     SWIFT_PRIVATE;
    std::optional<PickerBottomViewConfig> bottomView     SWIFT_PRIVATE;
    std::optional<bool> allowAddCamera     SWIFT_PRIVATE;
    std::optional<PhotoListCameraCellConfig> cameraCell     SWIFT_PRIVATE;
    std::optional<bool> finishSelectionAfterTakingPhoto     SWIFT_PRIVATE;
    std::optional<PhotoListCameraTypeConfig> cameraType     SWIFT_PRIVATE;
    std::optional<bool> takePictureCompletionToSelected     SWIFT_PRIVATE;
    std::optional<bool> isSaveSystemAlbum     SWIFT_PRIVATE;
    std::optional<PhotoListSaveSystemAlbumTypeConfig> saveSystemAlbumType     SWIFT_PRIVATE;
    std::optional<bool> allowAddLimit     SWIFT_PRIVATE;
    std::optional<PhotoListLimitCellConfig> limitCell     SWIFT_PRIVATE;
    std::optional<bool> isShowAssetNumber     SWIFT_PRIVATE;
    std::optional<PhotoListAssetNumberConfig> assetNumber     SWIFT_PRIVATE;
    std::optional<EmptyViewConfig> emptyView     SWIFT_PRIVATE;
    std::optional<PhotoPickerPreviewJumpStyleOption> previewStyle     SWIFT_PRIVATE;
    std::optional<std::string> selectedAssetIdentifier     SWIFT_PRIVATE;

  public:
    PhotoListConfig() = default;
    explicit PhotoListConfig(std::optional<AlbumTitleViewConfig> titleView, std::optional<SortOption> sort, std::optional<std::string> backgroundColor, std::optional<std::string> backgroundDarkColor, std::optional<std::string> cancelImageName, std::optional<std::string> cancelDarkImageName, std::optional<bool> isShowFilterItem, std::optional<std::string> filterThemeColor, std::optional<std::string> filterThemeDarkColor, std::optional<double> rowNumber, std::optional<double> landscapeRowNumber, std::optional<double> spltRowNumber, std::optional<double> spacing, std::optional<bool> allowHapticTouchPreview, std::optional<bool> allowAddMenuElements, std::optional<bool> allowSwipeToSelect, std::optional<bool> swipeSelectAllowAutoScroll, std::optional<double> swipeSelectIgnoreLeftArea, std::optional<double> swipeSelectScrollSpeed, std::optional<double> autoSwipeTopAreaHeight, std::optional<double> autoSwipeBottomAreaHeight, std::optional<PhotoListCellConfig> cell, std::optional<PickerBottomViewConfig> bottomView, std::optional<bool> allowAddCamera, std::optional<PhotoListCameraCellConfig> cameraCell, std::optional<bool> finishSelectionAfterTakingPhoto, std::optional<PhotoListCameraTypeConfig> cameraType, std::optional<bool> takePictureCompletionToSelected, std::optional<bool> isSaveSystemAlbum, std::optional<PhotoListSaveSystemAlbumTypeConfig> saveSystemAlbumType, std::optional<bool> allowAddLimit, std::optional<PhotoListLimitCellConfig> limitCell, std::optional<bool> isShowAssetNumber, std::optional<PhotoListAssetNumberConfig> assetNumber, std::optional<EmptyViewConfig> emptyView, std::optional<PhotoPickerPreviewJumpStyleOption> previewStyle, std::optional<std::string> selectedAssetIdentifier): titleView(titleView), sort(sort), backgroundColor(backgroundColor), backgroundDarkColor(backgroundDarkColor), cancelImageName(cancelImageName), cancelDarkImageName(cancelDarkImageName), isShowFilterItem(isShowFilterItem), filterThemeColor(filterThemeColor), filterThemeDarkColor(filterThemeDarkColor), rowNumber(rowNumber), landscapeRowNumber(landscapeRowNumber), spltRowNumber(spltRowNumber), spacing(spacing), allowHapticTouchPreview(allowHapticTouchPreview), allowAddMenuElements(allowAddMenuElements), allowSwipeToSelect(allowSwipeToSelect), swipeSelectAllowAutoScroll(swipeSelectAllowAutoScroll), swipeSelectIgnoreLeftArea(swipeSelectIgnoreLeftArea), swipeSelectScrollSpeed(swipeSelectScrollSpeed), autoSwipeTopAreaHeight(autoSwipeTopAreaHeight), autoSwipeBottomAreaHeight(autoSwipeBottomAreaHeight), cell(cell), bottomView(bottomView), allowAddCamera(allowAddCamera), cameraCell(cameraCell), finishSelectionAfterTakingPhoto(finishSelectionAfterTakingPhoto), cameraType(cameraType), takePictureCompletionToSelected(takePictureCompletionToSelected), isSaveSystemAlbum(isSaveSystemAlbum), saveSystemAlbumType(saveSystemAlbumType), allowAddLimit(allowAddLimit), limitCell(limitCell), isShowAssetNumber(isShowAssetNumber), assetNumber(assetNumber), emptyView(emptyView), previewStyle(previewStyle), selectedAssetIdentifier(selectedAssetIdentifier) {}

  public:
    friend bool operator==(const PhotoListConfig& lhs, const PhotoListConfig& rhs) = default;
  };

} // namespace margelo::nitro::hxphotopicker

namespace margelo::nitro {

  // C++ PhotoListConfig <> JS PhotoListConfig (object)
  template <>
  struct JSIConverter<margelo::nitro::hxphotopicker::PhotoListConfig> final {
    static inline margelo::nitro::hxphotopicker::PhotoListConfig fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
      jsi::Object obj = arg.asObject(runtime);
      return margelo::nitro::hxphotopicker::PhotoListConfig(
        JSIConverter<std::optional<margelo::nitro::hxphotopicker::AlbumTitleViewConfig>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "titleView"))),
        JSIConverter<std::optional<margelo::nitro::hxphotopicker::SortOption>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "sort"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "backgroundColor"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "backgroundDarkColor"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "cancelImageName"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "cancelDarkImageName"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "isShowFilterItem"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "filterThemeColor"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "filterThemeDarkColor"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "rowNumber"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "landscapeRowNumber"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "spltRowNumber"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "spacing"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "allowHapticTouchPreview"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "allowAddMenuElements"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "allowSwipeToSelect"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "swipeSelectAllowAutoScroll"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "swipeSelectIgnoreLeftArea"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "swipeSelectScrollSpeed"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "autoSwipeTopAreaHeight"))),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "autoSwipeBottomAreaHeight"))),
        JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListCellConfig>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "cell"))),
        JSIConverter<std::optional<margelo::nitro::hxphotopicker::PickerBottomViewConfig>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "bottomView"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "allowAddCamera"))),
        JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListCameraCellConfig>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "cameraCell"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "finishSelectionAfterTakingPhoto"))),
        JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListCameraTypeConfig>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "cameraType"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "takePictureCompletionToSelected"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "isSaveSystemAlbum"))),
        JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListSaveSystemAlbumTypeConfig>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "saveSystemAlbumType"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "allowAddLimit"))),
        JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListLimitCellConfig>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "limitCell"))),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "isShowAssetNumber"))),
        JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListAssetNumberConfig>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "assetNumber"))),
        JSIConverter<std::optional<margelo::nitro::hxphotopicker::EmptyViewConfig>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "emptyView"))),
        JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoPickerPreviewJumpStyleOption>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "previewStyle"))),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "selectedAssetIdentifier")))
      );
    }
    static inline jsi::Value toJSI(jsi::Runtime& runtime, const margelo::nitro::hxphotopicker::PhotoListConfig& arg) {
      jsi::Object obj(runtime);
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "titleView"), JSIConverter<std::optional<margelo::nitro::hxphotopicker::AlbumTitleViewConfig>>::toJSI(runtime, arg.titleView));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "sort"), JSIConverter<std::optional<margelo::nitro::hxphotopicker::SortOption>>::toJSI(runtime, arg.sort));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "backgroundColor"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.backgroundColor));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "backgroundDarkColor"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.backgroundDarkColor));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "cancelImageName"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.cancelImageName));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "cancelDarkImageName"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.cancelDarkImageName));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "isShowFilterItem"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.isShowFilterItem));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "filterThemeColor"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.filterThemeColor));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "filterThemeDarkColor"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.filterThemeDarkColor));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "rowNumber"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.rowNumber));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "landscapeRowNumber"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.landscapeRowNumber));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "spltRowNumber"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.spltRowNumber));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "spacing"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.spacing));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "allowHapticTouchPreview"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.allowHapticTouchPreview));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "allowAddMenuElements"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.allowAddMenuElements));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "allowSwipeToSelect"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.allowSwipeToSelect));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "swipeSelectAllowAutoScroll"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.swipeSelectAllowAutoScroll));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "swipeSelectIgnoreLeftArea"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.swipeSelectIgnoreLeftArea));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "swipeSelectScrollSpeed"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.swipeSelectScrollSpeed));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "autoSwipeTopAreaHeight"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.autoSwipeTopAreaHeight));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "autoSwipeBottomAreaHeight"), JSIConverter<std::optional<double>>::toJSI(runtime, arg.autoSwipeBottomAreaHeight));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "cell"), JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListCellConfig>>::toJSI(runtime, arg.cell));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "bottomView"), JSIConverter<std::optional<margelo::nitro::hxphotopicker::PickerBottomViewConfig>>::toJSI(runtime, arg.bottomView));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "allowAddCamera"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.allowAddCamera));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "cameraCell"), JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListCameraCellConfig>>::toJSI(runtime, arg.cameraCell));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "finishSelectionAfterTakingPhoto"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.finishSelectionAfterTakingPhoto));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "cameraType"), JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListCameraTypeConfig>>::toJSI(runtime, arg.cameraType));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "takePictureCompletionToSelected"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.takePictureCompletionToSelected));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "isSaveSystemAlbum"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.isSaveSystemAlbum));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "saveSystemAlbumType"), JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListSaveSystemAlbumTypeConfig>>::toJSI(runtime, arg.saveSystemAlbumType));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "allowAddLimit"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.allowAddLimit));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "limitCell"), JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListLimitCellConfig>>::toJSI(runtime, arg.limitCell));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "isShowAssetNumber"), JSIConverter<std::optional<bool>>::toJSI(runtime, arg.isShowAssetNumber));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "assetNumber"), JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListAssetNumberConfig>>::toJSI(runtime, arg.assetNumber));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "emptyView"), JSIConverter<std::optional<margelo::nitro::hxphotopicker::EmptyViewConfig>>::toJSI(runtime, arg.emptyView));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "previewStyle"), JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoPickerPreviewJumpStyleOption>>::toJSI(runtime, arg.previewStyle));
      obj.setProperty(runtime, PropNameIDCache::get(runtime, "selectedAssetIdentifier"), JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.selectedAssetIdentifier));
      return obj;
    }
    static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
      if (!value.isObject()) {
        return false;
      }
      jsi::Object obj = value.getObject(runtime);
      if (!nitro::isPlainObject(runtime, obj)) {
        return false;
      }
      if (!JSIConverter<std::optional<margelo::nitro::hxphotopicker::AlbumTitleViewConfig>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "titleView")))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::hxphotopicker::SortOption>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "sort")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "backgroundColor")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "backgroundDarkColor")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "cancelImageName")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "cancelDarkImageName")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "isShowFilterItem")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "filterThemeColor")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "filterThemeDarkColor")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "rowNumber")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "landscapeRowNumber")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "spltRowNumber")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "spacing")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "allowHapticTouchPreview")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "allowAddMenuElements")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "allowSwipeToSelect")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "swipeSelectAllowAutoScroll")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "swipeSelectIgnoreLeftArea")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "swipeSelectScrollSpeed")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "autoSwipeTopAreaHeight")))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "autoSwipeBottomAreaHeight")))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListCellConfig>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "cell")))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::hxphotopicker::PickerBottomViewConfig>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "bottomView")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "allowAddCamera")))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListCameraCellConfig>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "cameraCell")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "finishSelectionAfterTakingPhoto")))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListCameraTypeConfig>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "cameraType")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "takePictureCompletionToSelected")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "isSaveSystemAlbum")))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListSaveSystemAlbumTypeConfig>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "saveSystemAlbumType")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "allowAddLimit")))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListLimitCellConfig>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "limitCell")))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "isShowAssetNumber")))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoListAssetNumberConfig>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "assetNumber")))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::hxphotopicker::EmptyViewConfig>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "emptyView")))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::hxphotopicker::PhotoPickerPreviewJumpStyleOption>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "previewStyle")))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, PropNameIDCache::get(runtime, "selectedAssetIdentifier")))) return false;
      return true;
    }
  };

} // namespace margelo::nitro
